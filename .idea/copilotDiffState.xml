<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/.env">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.env" />
              <option name="updatedContent" value="# Google AI API Key&#10;GOOGLE_AI_API_KEY=your_google_ai_api_key_here&#10;&#10;# 사용법:&#10;# 1. Google AI Studio (https://aistudio.google.com/)에 접속&#10;# 2. API 키를 생성&#10;# 3. 위의 your_google_ai_api_key_here 부분을 실제 API 키로 교체" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/GUI/gui.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/GUI/gui.py" />
              <option name="originalContent" value="import tkinter as tk&#10;from tkinter import ttk, messagebox, filedialog&#10;import threading&#10;import sys&#10;import os&#10;from datetime import datetime&#10;from PIL import Image, ImageTk&#10;import matplotlib.pyplot as plt&#10;from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg&#10;import matplotlib.font_manager as fm&#10;&#10;# optimizer 모듈 import를 위한 경로 추가&#10;sys.path.append(os.path.join(os.path.dirname(__file__), '..', 'optimizer'))&#10;&#10;try:&#10;    from classic_opt import PortfolioOptimizer&#10;    from quantum_opt import QuantumPortfolioOptimizer&#10;    OPTIMIZER_AVAILABLE = True&#10;except ImportError as e:&#10;    print(f&quot;Optimizer import error: {e}&quot;)&#10;    OPTIMIZER_AVAILABLE = False&#10;&#10;class StockAIGUI:&#10;    def __init__(self, root):&#10;        self.root = root&#10;        self.setup_ui()&#10;        self.result_data = None&#10;&#10;    def setup_ui(self):&#10;        &quot;&quot;&quot;UI 구성 요소 설정&quot;&quot;&quot;&#10;        self.root.title(&quot;Stock AI - Portfolio Optimizer&quot;)&#10;        self.root.geometry(&quot;800x700&quot;)&#10;        self.root.configure(bg='#f0f0f0')&#10;&#10;        # 메인 프레임&#10;        main_frame = ttk.Frame(self.root, padding=&quot;20&quot;)&#10;        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))&#10;&#10;        # 제목&#10;        title_label = tk.Label(&#10;            main_frame,&#10;            text=&quot;Stock AI&quot;,&#10;            font=(&quot;Arial&quot;, 32, &quot;bold&quot;),&#10;            bg='#f0f0f0',&#10;            fg='#2c3e50'&#10;        )&#10;        title_label.grid(row=0, column=0, columnspan=2, pady=(0, 10))&#10;&#10;        # 부제목&#10;        subtitle_label = tk.Label(&#10;            main_frame,&#10;            text=&quot;It's the economy, stupid!&quot;,&#10;            font=(&quot;Arial&quot;, 14, &quot;italic&quot;),&#10;            bg='#f0f0f0',&#10;            fg='#7f8c8d'&#10;        )&#10;        subtitle_label.grid(row=1, column=0, columnspan=2, pady=(0, 30))&#10;&#10;        # 투자 금액 입력 섹션&#10;        investment_frame = ttk.LabelFrame(main_frame, text=&quot;투자 설정&quot;, padding=&quot;15&quot;)&#10;        investment_frame.grid(row=2, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 20))&#10;&#10;        # 투자 금액 입력&#10;        ttk.Label(investment_frame, text=&quot;투자 금액 (원):&quot;).grid(row=0, column=0, sticky=tk.W, pady=5)&#10;        self.amount_var = tk.StringVar(value=&quot;10000000&quot;)&#10;        amount_entry = ttk.Entry(investment_frame, textvariable=self.amount_var, font=(&quot;Arial&quot;, 12), width=20)&#10;        amount_entry.grid(row=0, column=1, sticky=(tk.W, tk.E), pady=5, padx=(10, 0))&#10;&#10;        # 주식 선택 방법&#10;        ttk.Label(investment_frame, text=&quot;주식 선택:&quot;).grid(row=1, column=0, sticky=tk.W, pady=5)&#10;&#10;        self.stock_method_var = tk.StringVar(value=&quot;sample&quot;)&#10;        method_frame = ttk.Frame(investment_frame)&#10;        method_frame.grid(row=1, column=1, sticky=(tk.W, tk.E), pady=5, padx=(10, 0))&#10;&#10;        ttk.Radiobutton(method_frame, text=&quot;샘플 주식 사용&quot;, variable=self.stock_method_var, value=&quot;sample&quot;).grid(row=0, column=0, sticky=tk.W)&#10;        ttk.Radiobutton(method_frame, text=&quot;직접 입력&quot;, variable=self.stock_method_var, value=&quot;manual&quot;).grid(row=0, column=1, sticky=tk.W, padx=(20, 0))&#10;        ttk.Radiobutton(method_frame, text=&quot;JSON 파일&quot;, variable=self.stock_method_var, value=&quot;json&quot;).grid(row=0, column=2, sticky=tk.W, padx=(20, 0))&#10;&#10;        # 직접 입력 필드&#10;        ttk.Label(investment_frame, text=&quot;주식 코드:&quot;).grid(row=2, column=0, sticky=tk.W, pady=5)&#10;        self.stocks_var = tk.StringVar(value=&quot;005930,000660,035420,051910,068270&quot;)&#10;        stocks_entry = ttk.Entry(investment_frame, textvariable=self.stocks_var, font=(&quot;Arial&quot;, 10), width=40)&#10;        stocks_entry.grid(row=2, column=1, sticky=(tk.W, tk.E), pady=5, padx=(10, 0))&#10;&#10;        # JSON 파일 선택&#10;        json_frame = ttk.Frame(investment_frame)&#10;        json_frame.grid(row=3, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=5)&#10;&#10;        ttk.Label(json_frame, text=&quot;JSON 파일:&quot;).grid(row=0, column=0, sticky=tk.W)&#10;        self.json_file_var = tk.StringVar()&#10;        ttk.Entry(json_frame, textvariable=self.json_file_var, width=30, state=&quot;readonly&quot;).grid(row=0, column=1, sticky=(tk.W, tk.E), padx=(10, 5))&#10;        ttk.Button(json_frame, text=&quot;파일 선택&quot;, command=self.select_json_file).grid(row=0, column=2)&#10;&#10;        # 최적화 방법 선택&#10;        optimizer_frame = ttk.LabelFrame(main_frame, text=&quot;최적화 방법&quot;, padding=&quot;15&quot;)&#10;        optimizer_frame.grid(row=3, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 20))&#10;&#10;        self.optimizer_var = tk.StringVar(value=&quot;classic&quot;)&#10;        ttk.Radiobutton(optimizer_frame, text=&quot;클래식 최적화&quot;, variable=self.optimizer_var, value=&quot;classic&quot;).grid(row=0, column=0, sticky=tk.W, pady=5)&#10;        ttk.Radiobutton(optimizer_frame, text=&quot;양자 최적화 (시뮬레이터)&quot;, variable=self.optimizer_var, value=&quot;quantum_sim&quot;).grid(row=0, column=1, sticky=tk.W, padx=(20, 0), pady=5)&#10;        ttk.Radiobutton(optimizer_frame, text=&quot;양자 최적화 (IBM 하드웨어)&quot;, variable=self.optimizer_var, value=&quot;quantum_hw&quot;).grid(row=0, column=2, sticky=tk.W, padx=(20, 0), pady=5)&#10;&#10;        # 최적화 실행 버튼&#10;        button_frame = ttk.Frame(main_frame)&#10;        button_frame.grid(row=4, column=0, columnspan=2, pady=20)&#10;&#10;        self.optimize_button = ttk.Button(&#10;            button_frame,&#10;            text=&quot;포트폴리오 최적화 실행&quot;,&#10;            command=self.run_optimization,&#10;            style=&quot;Accent.TButton&quot;&#10;        )&#10;        self.optimize_button.grid(row=0, column=0, padx=10)&#10;&#10;        ttk.Button(button_frame, text=&quot;결과 저장&quot;, command=self.save_results).grid(row=0, column=1, padx=10)&#10;        ttk.Button(button_frame, text=&quot;차트 보기&quot;, command=self.show_chart).grid(row=0, column=2, padx=10)&#10;&#10;        # 진행 상황 표시&#10;        self.progress_var = tk.StringVar(value=&quot;대기 중...&quot;)&#10;        progress_label = ttk.Label(main_frame, textvariable=self.progress_var, font=(&quot;Arial&quot;, 10))&#10;        progress_label.grid(row=5, column=0, columnspan=2, pady=10)&#10;&#10;        self.progress_bar = ttk.Progressbar(main_frame, mode='indeterminate')&#10;        self.progress_bar.grid(row=6, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 20))&#10;&#10;        # 결과 표시 영역&#10;        result_frame = ttk.LabelFrame(main_frame, text=&quot;최적화 결과&quot;, padding=&quot;15&quot;)&#10;        result_frame.grid(row=7, column=0, columnspan=2, sticky=(tk.W, tk.E, tk.N, tk.S), pady=(0, 20))&#10;&#10;        # 결과 텍스트 위젯 (스크롤 가능)&#10;        text_frame = ttk.Frame(result_frame)&#10;        text_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))&#10;&#10;        self.result_text = tk.Text(text_frame, height=15, width=70, font=(&quot;Consolas&quot;, 10))&#10;        scrollbar = ttk.Scrollbar(text_frame, orient=&quot;vertical&quot;, command=self.result_text.yview)&#10;        self.result_text.configure(yscrollcommand=scrollbar.set)&#10;&#10;        self.result_text.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))&#10;        scrollbar.grid(row=0, column=1, sticky=(tk.N, tk.S))&#10;&#10;        # 그리드 가중치 설정&#10;        self.root.columnconfigure(0, weight=1)&#10;        self.root.rowconfigure(0, weight=1)&#10;        main_frame.columnconfigure(1, weight=1)&#10;        main_frame.rowconfigure(7, weight=1)&#10;        investment_frame.columnconfigure(1, weight=1)&#10;        json_frame.columnconfigure(1, weight=1)&#10;        result_frame.columnconfigure(0, weight=1)&#10;        result_frame.rowconfigure(0, weight=1)&#10;        text_frame.columnconfigure(0, weight=1)&#10;        text_frame.rowconfigure(0, weight=1)&#10;&#10;        # 초기 메시지 표시&#10;        self.display_welcome_message()&#10;&#10;    def display_welcome_message(self):&#10;        &quot;&quot;&quot;환영 메시지 표시&quot;&quot;&quot;&#10;        welcome_msg = &quot;&quot;&quot;&#10; Stock AI 포트폴리오 최적화 시스템에 오신 것을 환영합니다!&#10;&#10; 기능:&#10;• 클래식 최적화: 전통적인 평균-분산 최적화&#10;• 양자 최적화: 최신 양자 컴퓨팅 기술 활용&#10;• 실시간 주식 데이터 수집 및 분석&#10;• 포트폴리오 성과 시각화&#10;&#10; 사용 방법:&#10;1. 투자 금액을 입력하세요&#10;2. 주식 선택 방법을 선택하세요&#10;3. 최적화 방법을 선택하세요&#10;4. '포트폴리오 최적화 실행' 버튼을 클릭하세요&#10;&#10; 팁: 샘플 주식(삼성전자, SK하이닉스, 네이버, LG화학, 셀트리온)으로 먼저 테스트해보세요!&#10;&quot;&quot;&quot;&#10;        self.result_text.delete(1.0, tk.END)&#10;        self.result_text.insert(tk.END, welcome_msg)&#10;&#10;    def select_json_file(self):&#10;        &quot;&quot;&quot;JSON 파일 선택&quot;&quot;&quot;&#10;        filename = filedialog.askopenfilename(&#10;            title=&quot;주식 리스트 JSON 파일 선택&quot;,&#10;            filetypes=[(&quot;JSON files&quot;, &quot;*.json&quot;), (&quot;All files&quot;, &quot;*.*&quot;)]&#10;        )&#10;        if filename:&#10;            self.json_file_var.set(filename)&#10;&#10;    def get_stock_list(self):&#10;        &quot;&quot;&quot;선택된 방법에 따라 주식 리스트 반환&quot;&quot;&quot;&#10;        method = self.stock_method_var.get()&#10;&#10;        if method == &quot;sample&quot;:&#10;            return [&quot;005930&quot;, &quot;000660&quot;, &quot;035420&quot;, &quot;051910&quot;, &quot;068270&quot;]  # 샘플 주식&#10;        elif method == &quot;manual&quot;:&#10;            stocks_str = self.stocks_var.get().strip()&#10;            if not stocks_str:&#10;                raise ValueError(&quot;주식 코드를 입력해주세요.&quot;)&#10;            return [s.strip() for s in stocks_str.split(',')]&#10;        elif method == &quot;json&quot;:&#10;            json_file = self.json_file_var.get().strip()&#10;            if not json_file:&#10;                raise ValueError(&quot;JSON 파일을 선택해주세요.&quot;)&#10;            return json_file&#10;        else:&#10;            raise ValueError(&quot;올바른 주식 선택 방법을 선택해주세요.&quot;)&#10;&#10;    def validate_inputs(self):&#10;        &quot;&quot;&quot;입력값 검증&quot;&quot;&quot;&#10;        try:&#10;            amount = int(self.amount_var.get().replace(',', ''))&#10;            if amount &lt;= 0:&#10;                raise ValueError(&quot;투자 금액은 0보다 커야 합니다.&quot;)&#10;        except ValueError:&#10;            raise ValueError(&quot;올바른 투자 금액을 입력해주세요.&quot;)&#10;&#10;        stock_list = self.get_stock_list()&#10;        return amount, stock_list&#10;&#10;    def run_optimization(self):&#10;        &quot;&quot;&quot;최적화 실행 (별도 스레드에서)&quot;&quot;&quot;&#10;        try:&#10;            # 입력값 검증&#10;            amount, stock_list = self.validate_inputs()&#10;&#10;            # UI 업데이트&#10;            self.optimize_button.config(state=&quot;disabled&quot;)&#10;            self.progress_bar.start()&#10;            self.progress_var.set(&quot;최적화 진행 중...&quot;)&#10;            self.result_text.delete(1.0, tk.END)&#10;            self.result_text.insert(tk.END, &quot; 포트폴리오 최적화를 시작합니다...\n\n&quot;)&#10;&#10;            # 별도 스레드에서 최적화 실행&#10;            threading.Thread(&#10;                target=self.optimize_portfolio,&#10;                args=(amount, stock_list),&#10;                daemon=True&#10;            ).start()&#10;&#10;        except Exception as e:&#10;            messagebox.showerror(&quot;입력 오류&quot;, str(e))&#10;&#10;    def optimize_portfolio(self, amount, stock_list):&#10;        &quot;&quot;&quot;실제 최적화 실행&quot;&quot;&quot;&#10;        try:&#10;            if not OPTIMIZER_AVAILABLE:&#10;                raise Exception(&quot;Optimizer 모듈을 찾을 수 없습니다.&quot;)&#10;&#10;            optimizer_type = self.optimizer_var.get()&#10;&#10;            # 진행 상황 업데이트&#10;            self.root.after(0, lambda: self.update_progress(&quot;데이터 수집 중...&quot;))&#10;&#10;            print(f&quot;최적화 시작 - 방법: {optimizer_type}, 금액: {amount}, 주식: {stock_list}&quot;)&#10;&#10;            result = None&#10;            if optimizer_type == &quot;classic&quot;:&#10;                # 클래식 최적화&#10;                if isinstance(stock_list, str):  # JSON 파일인 경우&#10;                    from classic_opt import optimize_portfolio_from_json&#10;                    result = optimize_portfolio_from_json(stock_list, amount)&#10;                else:&#10;                    optimizer = PortfolioOptimizer(stock_list, amount)&#10;                    result = optimizer.run_optimization()&#10;&#10;            else:&#10;                # 양자 최적화&#10;                use_hardware = (optimizer_type == &quot;quantum_hw&quot;)&#10;&#10;                if isinstance(stock_list, str):  # JSON 파일인 경우&#10;                    from quantum_opt import optimize_quantum_portfolio_from_json&#10;                    result = optimize_quantum_portfolio_from_json(stock_list, amount, use_real_quantum=use_hardware)&#10;                else:&#10;                    optimizer = QuantumPortfolioOptimizer(stock_list, amount, use_real_quantum=use_hardware)&#10;                    result = optimizer.run_optimization()&#10;&#10;            # 결과 처리&#10;            print(f&quot;최적화 결과: {result is not None}&quot;)&#10;            if result:&#10;                print(f&quot;결과 키들: {list(result.keys()) if isinstance(result, dict) else 'Not a dict'}&quot;)&#10;                # 스레드 안전한 방식으로 결과 업데이트&#10;                self.result_data = result&#10;                # GUI 업데이트는 메인 스레드에서 실행되도록 예약&#10;                self.root.after(100, lambda: self.display_results_safe(result))&#10;            else:&#10;                print(&quot;결과가 None입니다.&quot;)&#10;                self.root.after(100, lambda: self.show_error(&quot;최적화에 실패했습니다. 콘솔을 확인해주세요.&quot;))&#10;&#10;        except Exception as e:&#10;            print(f&quot;최적화 중 예외 발생: {e}&quot;)&#10;            import traceback&#10;            print(f&quot;상세 오류:\n{traceback.format_exc()}&quot;)&#10;            self.root.after(100, lambda: self.show_error(f&quot;오류 발생: {str(e)}&quot;))&#10;        finally:&#10;            # UI 복원&#10;            self.root.after(200, self.reset_ui)&#10;&#10;    def display_results_safe(self, result):&#10;        &quot;&quot;&quot;스레드 안전한 결과 표시&quot;&quot;&quot;&#10;        try:&#10;            print(&quot;GUI에서 결과 표시 시작&quot;)&#10;            self.display_results(result)&#10;            print(&quot;GUI에서 결과 표시 완료&quot;)&#10;        except Exception as e:&#10;            print(f&quot;결과 표시 중 오류: {e}&quot;)&#10;            import traceback&#10;            print(f&quot;상세 오류:\n{traceback.format_exc()}&quot;)&#10;            self.show_error(f&quot;결과 표시 중 오류: {str(e)}&quot;)&#10;&#10;    def display_results(self, result):&#10;        &quot;&quot;&quot;결과 표시&quot;&quot;&quot;&#10;        print(&quot;display_results 호출됨&quot;)&#10;        try:&#10;            self.result_text.delete(1.0, tk.END)&#10;&#10;            # 결과 데이터 검증&#10;            if not isinstance(result, dict):&#10;                raise ValueError(&quot;결과가 딕셔너리 형태가 아닙니다.&quot;)&#10;&#10;            if 'performance' not in result:&#10;                raise ValueError(&quot;성과 데이터가 없습니다.&quot;)&#10;&#10;            if 'allocations' not in result:&#10;                raise ValueError(&quot;배분 데이터가 없습니다.&quot;)&#10;&#10;            # 성과 요약&#10;            perf = result['performance']&#10;            method = result.get('method', '알 수 없음')&#10;&#10;            result_msg = f&quot;&quot;&quot;&#10;✅ 포트폴리오 최적화 완료!&#10;&#10; 최적화 방법: {method}&#10; 성과 요약:&#10;  • 예상 연간 수익률: {perf['expected_return']:.2%}&#10;  • 예상 연간 변동성: {perf['volatility']:.2%}&#10;  • 샤프 비율: {perf['sharpe_ratio']:.3f}&#10;&#10; 투자 배분:&#10;&quot;&quot;&quot;&#10;&#10;            # 배분 정보 추가&#10;            allocations = result['allocations']&#10;            print(f&quot;배분 데이터 개수: {len(allocations)}&quot;)&#10;&#10;            for i, allocation in enumerate(allocations[:10]):  # 상위 10개만 표시&#10;                if allocation.get('weight', 0) &gt; 0.001:  # 0.1% 이상만 표시&#10;                    symbol = allocation.get('symbol', 'Unknown')&#10;                    amount = allocation.get('amount', 0)&#10;                    percentage = allocation.get('percentage', 0)&#10;                    result_msg += f&quot;  {i+1:2d}. {symbol}: {amount:,}원 ({percentage:.1f}%)\n&quot;&#10;&#10;            if 'chart_file' in result:&#10;                result_msg += f&quot;\n 차트 파일: {result['chart_file']}&quot;&#10;&#10;            if 'backend_info' in result:&#10;                backend = result['backend_info']&#10;                result_msg += f&quot;\n️ 백엔드: {backend['name']} ({backend['type']})&quot;&#10;&#10;            result_msg += f&quot;\n\n⏰ 완료 시간: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}&quot;&#10;&#10;            # 텍스트 위젯에 결과 표시&#10;            self.result_text.insert(tk.END, result_msg)&#10;            self.result_text.see(tk.END)  # 마지막으로 스크롤&#10;&#10;            # 상태 업데이트&#10;            self.progress_var.set(&quot;최적화 완료!&quot;)&#10;&#10;            print(&quot;결과 표시 완료&quot;)&#10;&#10;        except Exception as e:&#10;            print(f&quot;결과 표시 중 내부 오류: {e}&quot;)&#10;            import traceback&#10;            print(f&quot;상세 오류:\n{traceback.format_exc()}&quot;)&#10;            self.show_error(f&quot;결과 표시 오류: {str(e)}&quot;)&#10;&#10;    def show_error(self, error_msg):&#10;        &quot;&quot;&quot;오류 메시지 표시&quot;&quot;&quot;&#10;        self.result_text.delete(1.0, tk.END)&#10;        self.result_text.insert(tk.END, f&quot;❌ {error_msg}&quot;)&#10;        self.progress_var.set(&quot;오류 발생&quot;)&#10;        messagebox.showerror(&quot;오류&quot;, error_msg)&#10;&#10;    def reset_ui(self):&#10;        &quot;&quot;&quot;UI 상태 복원&quot;&quot;&quot;&#10;        self.optimize_button.config(state=&quot;normal&quot;)&#10;        self.progress_bar.stop()&#10;        if not hasattr(self, 'result_data') or self.result_data is None:&#10;            self.progress_var.set(&quot;대기 중...&quot;)&#10;&#10;    def save_results(self):&#10;        &quot;&quot;&quot;결과 저장&quot;&quot;&quot;&#10;        if not hasattr(self, 'result_data') or self.result_data is None:&#10;            messagebox.showwarning(&quot;경고&quot;, &quot;저장할 결과가 없습니다.&quot;)&#10;            return&#10;&#10;        try:&#10;            filename = filedialog.asksaveasfilename(&#10;                title=&quot;결과 저장&quot;,&#10;                defaultextension=&quot;.txt&quot;,&#10;                filetypes=[(&quot;Text files&quot;, &quot;*.txt&quot;), (&quot;All files&quot;, &quot;*.*&quot;)]&#10;            )&#10;&#10;            if filename:&#10;                with open(filename, 'w', encoding='utf-8') as f:&#10;                    f.write(self.result_text.get(1.0, tk.END))&#10;                messagebox.showinfo(&quot;성공&quot;, f&quot;결과가 저장되었습니다: {filename}&quot;)&#10;        except Exception as e:&#10;            messagebox.showerror(&quot;오류&quot;, f&quot;저장 중 오류 발생: {str(e)}&quot;)&#10;&#10;    def show_chart(self):&#10;        &quot;&quot;&quot;차트 및 상세 결과 창 표시&quot;&quot;&quot;&#10;        if not hasattr(self, 'result_data') or self.result_data is None:&#10;            messagebox.showwarning(&quot;경고&quot;, &quot;표시할 차트가 없습니다.&quot;)&#10;            return&#10;&#10;        # 새 창 생성&#10;        chart_window = tk.Toplevel(self.root)&#10;        chart_window.title(&quot;포트폴리오 분석 결과&quot;)&#10;        chart_window.geometry(&quot;1200x800&quot;)&#10;        chart_window.configure(bg='#f0f0f0')&#10;&#10;        # 메인 프레임&#10;        main_frame = ttk.Frame(chart_window, padding=&quot;10&quot;)&#10;        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))&#10;&#10;        # 창 크기 조절 가능하도록 설정&#10;        chart_window.columnconfigure(0, weight=1)&#10;        chart_window.rowconfigure(0, weight=1)&#10;        main_frame.columnconfigure(0, weight=1)&#10;        main_frame.rowconfigure(1, weight=1)&#10;&#10;        # 제목&#10;        title_label = tk.Label(&#10;            main_frame,&#10;            text=&quot;�� 포트폴리오 분석 결과&quot;,&#10;            font=(&quot;Arial&quot;, 18, &quot;bold&quot;),&#10;            bg='#f0f0f0',&#10;            fg='#2c3e50'&#10;        )&#10;        title_label.grid(row=0, column=0, pady=(0, 20))&#10;&#10;        # 노트북 (탭) 위젯 생성&#10;        notebook = ttk.Notebook(main_frame)&#10;        notebook.grid(row=1, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))&#10;&#10;        # 탭 1: 차트 이미지&#10;        chart_frame = ttk.Frame(notebook, padding=&quot;10&quot;)&#10;        notebook.add(chart_frame, text=&quot; 포트폴리오 차트&quot;)&#10;&#10;        # 탭 2: 상세 결과&#10;        details_frame = ttk.Frame(notebook, padding=&quot;10&quot;)&#10;        notebook.add(details_frame, text=&quot; 상세 분석&quot;)&#10;&#10;        # 탭 3: 투자 배분&#10;        allocation_frame = ttk.Frame(notebook, padding=&quot;10&quot;)&#10;        notebook.add(allocation_frame, text=&quot; 투자 배분&quot;)&#10;&#10;        # 차트 이미지 표시&#10;        self.display_chart_image(chart_frame)&#10;&#10;        # 상세 결과 표시&#10;        self.display_detailed_results(details_frame)&#10;&#10;        # 투자 배분 표시&#10;        self.display_allocation_table(allocation_frame)&#10;&#10;    def display_chart_image(self, parent_frame):&#10;        &quot;&quot;&quot;차트 이미지 표시&quot;&quot;&quot;&#10;        chart_file = self.result_data.get('chart_file')&#10;&#10;        if chart_file and os.path.exists(chart_file):&#10;            try:&#10;                # 이미지 로드 및 크기 조정&#10;                image = Image.open(chart_file)&#10;&#10;                # 창 크기에 맞게 이미지 크기 조정&#10;                display_size = (1000, 600)&#10;                image.thumbnail(display_size, Image.Resampling.LANCZOS)&#10;&#10;                photo = ImageTk.PhotoImage(image)&#10;&#10;                # 스크롤 가능한 프레임 생성&#10;                canvas = tk.Canvas(parent_frame, bg='white')&#10;                scrollbar_v = ttk.Scrollbar(parent_frame, orient=&quot;vertical&quot;, command=canvas.yview)&#10;                scrollbar_h = ttk.Scrollbar(parent_frame, orient=&quot;horizontal&quot;, command=canvas.xview)&#10;&#10;                canvas.configure(yscrollcommand=scrollbar_v.set, xscrollcommand=scrollbar_h.set)&#10;&#10;                # 이미지 표시&#10;                image_label = tk.Label(canvas, image=photo, bg='white')&#10;                image_label.image = photo  # 참조 유지&#10;&#10;                canvas.create_window(0, 0, anchor=&quot;nw&quot;, window=image_label)&#10;                canvas.update_idletasks()&#10;                canvas.configure(scrollregion=canvas.bbox(&quot;all&quot;))&#10;&#10;                # 그리드 배치&#10;                canvas.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))&#10;                scrollbar_v.grid(row=0, column=1, sticky=(tk.N, tk.S))&#10;                scrollbar_h.grid(row=1, column=0, sticky=(tk.W, tk.E))&#10;&#10;                # 그리드 가중치&#10;                parent_frame.columnconfigure(0, weight=1)&#10;                parent_frame.rowconfigure(0, weight=1)&#10;&#10;            except Exception as e:&#10;                error_label = tk.Label(&#10;                    parent_frame,&#10;                    text=f&quot;❌ 차트 이미지를 로드할 수 없습니다:\n{str(e)}&quot;,&#10;                    font=(&quot;Arial&quot;, 12),&#10;                    fg='red',&#10;                    justify=tk.CENTER&#10;                )&#10;                error_label.grid(row=0, column=0, padx=20, pady=20)&#10;        else:&#10;            no_chart_label = tk.Label(&#10;                parent_frame,&#10;                text=&quot; 차트 파일을 찾을 수 없습니다.&quot;,&#10;                font=(&quot;Arial&quot;, 14),&#10;                fg='gray',&#10;                justify=tk.CENTER&#10;            )&#10;            no_chart_label.grid(row=0, column=0, padx=20, pady=20)&#10;&#10;    def display_detailed_results(self, parent_frame):&#10;        &quot;&quot;&quot;상세 결과 표시&quot;&quot;&quot;&#10;        # 스크롤 가능한 텍스트 위젯&#10;        text_frame = ttk.Frame(parent_frame)&#10;        text_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))&#10;&#10;        text_widget = tk.Text(text_frame, font=(&quot;Consolas&quot;, 11), wrap=tk.WORD)&#10;        scrollbar = ttk.Scrollbar(text_frame, orient=&quot;vertical&quot;, command=text_widget.yview)&#10;        text_widget.configure(yscrollcommand=scrollbar.set)&#10;&#10;        # 상세 정보 텍스트 생성&#10;        perf = self.result_data['performance']&#10;        method = self.result_data.get('method', '알 수 없음')&#10;&#10;        detailed_text = f&quot;&quot;&quot;&#10; 포트폴리오 최적화 상세 결과&#10;{'=' * 50}&#10;&#10; 최적화 방법: {method}&#10;&#10; 포트폴리오 성과 지표:&#10;  • 예상 연간 수익률: {perf['expected_return']:.4%}&#10;  • 예상 연간 변동성: {perf['volatility']:.4%}&#10;  • 샤프 비율: {perf['sharpe_ratio']:.6f}&#10;  • 위험 대비 수익률: {perf['expected_return']/perf['volatility']:.4f}&#10;&#10; 투자 총액: {sum(allocation['amount'] for allocation in self.result_data['allocations']):,}원&#10;&#10; 전체 종목별 투자 배분:&#10;{'=' * 50}&#10;&quot;&quot;&quot;&#10;&#10;        # 모든 배분 정보 추가&#10;        for i, allocation in enumerate(self.result_data['allocations'], 1):&#10;            if allocation['weight'] &gt; 0.0001:  # 0.01% 이상만 표시&#10;                detailed_text += f&quot;{i:3d}. {allocation['symbol']:8s} | &quot;&#10;                detailed_text += f&quot;{allocation['name'][:20]:20s} | &quot;&#10;                detailed_text += f&quot;{allocation['amount']:&gt;12,}원 | &quot;&#10;                detailed_text += f&quot;{allocation['percentage']:&gt;6.2f}% | &quot;&#10;                detailed_text += f&quot;가중치: {allocation['weight']:.4f}\n&quot;&#10;&#10;        # 백엔드 정보 추가&#10;        if 'backend_info' in self.result_data:&#10;            backend = self.result_data['backend_info']&#10;            detailed_text += f&quot;&quot;&quot;&#10;&#10;️ 백엔드 정보:&#10;{'=' * 50}&#10;  • 백엔드 이름: {backend['name']}&#10;  • 백엔드 타입: {backend['type']}&#10;&quot;&quot;&quot;&#10;&#10;        # 차트 파일 정보 추가&#10;        if 'chart_file' in self.result_data:&#10;            detailed_text += f&quot;&quot;&quot;&#10;&#10; 차트 파일:&#10;{'=' * 50}&#10;  • 파일 경로: {self.result_data['chart_file']}&#10;  • 파일 존재: {'✅' if os.path.exists(self.result_data['chart_file']) else '❌'}&#10;&quot;&quot;&quot;&#10;&#10;        detailed_text += f&quot;&quot;&quot;&#10;&#10;⏰ 분석 완료 시간: {datetime.now().strftime('%Y년 %m월 %d일 %H시 %M분 %S초')}&#10;&#10; 참고사항:&#10;  • 이 결과는 과거 데이터를 기반으로 한 예측이며, 실제 수익을 보장하지 않습니다.&#10;  • 투자 결정 시 충분한 검토와 전문가 상담을 권장합니다.&#10;  • 포트폴리오는 정기적으로 재조정하는 것이 좋습니다.&#10;&quot;&quot;&quot;&#10;&#10;        # 텍스트 삽입&#10;        text_widget.insert(tk.END, detailed_text)&#10;        text_widget.config(state=tk.DISABLED)  # 읽기 전용으로 설정&#10;&#10;        # 위젯 배치&#10;        text_widget.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))&#10;        scrollbar.grid(row=0, column=1, sticky=(tk.N, tk.S))&#10;&#10;        # 그리드 가중치 설정&#10;        parent_frame.columnconfigure(0, weight=1)&#10;        parent_frame.rowconfigure(0, weight=1)&#10;        text_frame.columnconfigure(0, weight=1)&#10;        text_frame.rowconfigure(0, weight=1)&#10;&#10;    def display_allocation_table(self, parent_frame):&#10;        &quot;&quot;&quot;투자 배분 테이블 표시&quot;&quot;&quot;&#10;        # 테이블 프레임&#10;        table_frame = ttk.Frame(parent_frame)&#10;        table_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))&#10;&#10;        # 트리뷰 위젯 생성 (테이블)&#10;        columns = ('순위', '종목코드', '종목명', '투자금액', '비중(%)', '가중치')&#10;        tree = ttk.Treeview(table_frame, columns=columns, show='headings', height=15)&#10;&#10;        # 헤더 설정&#10;        tree.heading('순위', text='순위')&#10;        tree.heading('종목코드', text='종목코드')&#10;        tree.heading('종목명', text='종목명')&#10;        tree.heading('투자금액', text='투자금액(원)')&#10;        tree.heading('비��(%)', text='비중(%)')&#10;        tree.heading('가중치', text='가중치')&#10;&#10;        # 컬럼 너비 설정&#10;        tree.column('순위', width=50, anchor='center')&#10;        tree.column('종목코드', width=80, anchor='center')&#10;        tree.column('종목명', width=200, anchor='w')&#10;        tree.column('투자금액', width=120, anchor='e')&#10;        tree.column('비중(%)', width=80, anchor='e')&#10;        tree.column('가중치', width=100, anchor='e')&#10;&#10;        # 스크롤바 추가&#10;        scrollbar_table = ttk.Scrollbar(table_frame, orient=&quot;vertical&quot;, command=tree.yview)&#10;        tree.configure(yscrollcommand=scrollbar_table.set)&#10;&#10;        # 데이터 삽입&#10;        for i, allocation in enumerate(self.result_data['allocations'], 1):&#10;            if allocation['weight'] &gt; 0.0001:  # 0.01% 이상만 표시&#10;                tree.insert('', 'end', values=(&#10;                    i,&#10;                    allocation['symbol'],&#10;                    allocation['name'][:25],  # 이름 길이 제한&#10;                    f&quot;{allocation['amount']:,}&quot;,&#10;                    f&quot;{allocation['percentage']:.2f}&quot;,&#10;                    f&quot;{allocation['weight']:.4f}&quot;&#10;                ))&#10;&#10;        # 위젯 배치&#10;        tree.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))&#10;        scrollbar_table.grid(row=0, column=1, sticky=(tk.N, tk.S))&#10;&#10;        # 요약 정보 프레임&#10;        summary_frame = ttk.LabelFrame(parent_frame, text=&quot;포트폴리오 요약&quot;, padding=&quot;10&quot;)&#10;        summary_frame.grid(row=1, column=0, sticky=(tk.W, tk.E), pady=(10, 0))&#10;&#10;        # 요약 정보 레이블들&#10;        perf = self.result_data['performance']&#10;        total_amount = sum(allocation['amount'] for allocation in self.result_data['allocations'])&#10;        active_stocks = len([a for a in self.result_data['allocations'] if a['weight'] &gt; 0.0001])&#10;&#10;        summary_info = [&#10;            f&quot; 총 투자 금액: {total_amount:,}원&quot;,&#10;            f&quot; 활성 종목 수: {active_stocks}개&quot;,&#10;            f&quot; 예상 연간 수익률: {perf['expected_return']:.2%}&quot;,&#10;            f&quot; 예상 연간 변동성: {perf['volatility']:.2%}&quot;,&#10;            f&quot;⚡ 샤프 비율: {perf['sharpe_ratio']:.3f}&quot;&#10;        ]&#10;&#10;        for i, info in enumerate(summary_info):&#10;            label = ttk.Label(summary_frame, text=info, font=(&quot;Arial&quot;, 10))&#10;            label.grid(row=i//2, column=i%2, sticky=tk.W, padx=10, pady=2)&#10;&#10;        # 그리드 가중치 설정&#10;        parent_frame.columnconfigure(0, weight=1)&#10;        parent_frame.rowconfigure(0, weight=1)&#10;        table_frame.columnconfigure(0, weight=1)&#10;        table_frame.rowconfigure(0, weight=1)&#10;        summary_frame.columnconfigure(0, weight=1)&#10;        summary_frame.columnconfigure(1, weight=1)&#10;&#10;&#10;def main():&#10;    &quot;&quot;&quot;메인 함수&quot;&quot;&quot;&#10;    root = tk.Tk()&#10;    app = StockAIGUI(root)&#10;&#10;    # 스타일 설정&#10;    style = ttk.Style()&#10;    style.theme_use('clam')&#10;&#10;    # 애플리케이션 실행&#10;    root.mainloop()&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()&#10;" />
              <option name="updatedContent" value="import tkinter as tk&#10;from tkinter import ttk, messagebox, filedialog&#10;import threading&#10;import sys&#10;import os&#10;from datetime import datetime&#10;from PIL import Image, ImageTk&#10;import matplotlib.pyplot as plt&#10;from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg&#10;import matplotlib.font_manager as fm&#10;&#10;# optimizer 모듈 import를 위한 경로 추가&#10;sys.path.append(os.path.join(os.path.dirname(__file__), '..', 'optimizer'))&#10;&#10;try:&#10;    from classic_opt import PortfolioOptimizer&#10;    from quantum_opt import QuantumPortfolioOptimizer&#10;    OPTIMIZER_AVAILABLE = True&#10;except ImportError as e:&#10;    print(f&quot;Optimizer import error: {e}&quot;)&#10;    OPTIMIZER_AVAILABLE = False&#10;&#10;class StockAIGUI:&#10;    def __init__(self, root):&#10;        self.root = root&#10;        self.setup_ui()&#10;        self.result_data = None&#10;&#10;    def setup_ui(self):&#10;        &quot;&quot;&quot;UI 구성 요소 설정&quot;&quot;&quot;&#10;        self.root.title(&quot;Stock AI - Portfolio Optimizer&quot;)&#10;        self.root.geometry(&quot;800x700&quot;)&#10;        self.root.configure(bg='#f0f0f0')&#10;&#10;        # 메인 프레임&#10;        main_frame = ttk.Frame(self.root, padding=&quot;20&quot;)&#10;        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))&#10;&#10;        # 제목&#10;        title_label = tk.Label(&#10;            main_frame,&#10;            text=&quot;Stock AI&quot;,&#10;            font=(&quot;Arial&quot;, 32, &quot;bold&quot;),&#10;            bg='#f0f0f0',&#10;            fg='#2c3e50'&#10;        )&#10;        title_label.grid(row=0, column=0, columnspan=2, pady=(0, 10))&#10;&#10;        # 부제목&#10;        subtitle_label = tk.Label(&#10;            main_frame,&#10;            text=&quot;It's the economy, stupid!&quot;,&#10;            font=(&quot;Arial&quot;, 14, &quot;italic&quot;),&#10;            bg='#f0f0f0',&#10;            fg='#7f8c8d'&#10;        )&#10;        subtitle_label.grid(row=1, column=0, columnspan=2, pady=(0, 30))&#10;&#10;        # 투자 금액 입력 섹션&#10;        investment_frame = ttk.LabelFrame(main_frame, text=&quot;투자 설정&quot;, padding=&quot;15&quot;)&#10;        investment_frame.grid(row=2, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 20))&#10;&#10;        # 투자 금액 입력&#10;        ttk.Label(investment_frame, text=&quot;투자 금액 (원):&quot;).grid(row=0, column=0, sticky=tk.W, pady=5)&#10;        self.amount_var = tk.StringVar(value=&quot;10000000&quot;)&#10;        amount_entry = ttk.Entry(investment_frame, textvariable=self.amount_var, font=(&quot;Arial&quot;, 12), width=20)&#10;        amount_entry.grid(row=0, column=1, sticky=(tk.W, tk.E), pady=5, padx=(10, 0))&#10;&#10;        # 주식 선택 방법&#10;        ttk.Label(investment_frame, text=&quot;주식 선택:&quot;).grid(row=1, column=0, sticky=tk.W, pady=5)&#10;&#10;        self.stock_method_var = tk.StringVar(value=&quot;sample&quot;)&#10;        method_frame = ttk.Frame(investment_frame)&#10;        method_frame.grid(row=1, column=1, sticky=(tk.W, tk.E), pady=5, padx=(10, 0))&#10;&#10;        ttk.Radiobutton(method_frame, text=&quot;샘플 주식 사용&quot;, variable=self.stock_method_var, value=&quot;sample&quot;).grid(row=0, column=0, sticky=tk.W)&#10;        ttk.Radiobutton(method_frame, text=&quot;직접 입력&quot;, variable=self.stock_method_var, value=&quot;manual&quot;).grid(row=0, column=1, sticky=tk.W, padx=(20, 0))&#10;        ttk.Radiobutton(method_frame, text=&quot;JSON 파일&quot;, variable=self.stock_method_var, value=&quot;json&quot;).grid(row=0, column=2, sticky=tk.W, padx=(20, 0))&#10;&#10;        # 직접 입력 필드&#10;        ttk.Label(investment_frame, text=&quot;주식 코드:&quot;).grid(row=2, column=0, sticky=tk.W, pady=5)&#10;        self.stocks_var = tk.StringVar(value=&quot;005930,000660,035420,051910,068270&quot;)&#10;        stocks_entry = ttk.Entry(investment_frame, textvariable=self.stocks_var, font=(&quot;Arial&quot;, 10), width=40)&#10;        stocks_entry.grid(row=2, column=1, sticky=(tk.W, tk.E), pady=5, padx=(10, 0))&#10;&#10;        # JSON 파일 선택&#10;        json_frame = ttk.Frame(investment_frame)&#10;        json_frame.grid(row=3, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=5)&#10;&#10;        ttk.Label(json_frame, text=&quot;JSON 파일:&quot;).grid(row=0, column=0, sticky=tk.W)&#10;        self.json_file_var = tk.StringVar()&#10;        ttk.Entry(json_frame, textvariable=self.json_file_var, width=30, state=&quot;readonly&quot;).grid(row=0, column=1, sticky=(tk.W, tk.E), padx=(10, 5))&#10;        ttk.Button(json_frame, text=&quot;파일 선택&quot;, command=self.select_json_file).grid(row=0, column=2)&#10;&#10;        # 최적화 방법 선택&#10;        optimizer_frame = ttk.LabelFrame(main_frame, text=&quot;최적화 방법&quot;, padding=&quot;15&quot;)&#10;        optimizer_frame.grid(row=3, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 20))&#10;&#10;        self.optimizer_var = tk.StringVar(value=&quot;classic&quot;)&#10;        ttk.Radiobutton(optimizer_frame, text=&quot;클래식 최적화&quot;, variable=self.optimizer_var, value=&quot;classic&quot;).grid(row=0, column=0, sticky=tk.W, pady=5)&#10;        ttk.Radiobutton(optimizer_frame, text=&quot;양자 최적화 (시뮬레이터)&quot;, variable=self.optimizer_var, value=&quot;quantum_sim&quot;).grid(row=0, column=1, sticky=tk.W, padx=(20, 0), pady=5)&#10;        ttk.Radiobutton(optimizer_frame, text=&quot;양자 최적화 (IBM 하드웨어)&quot;, variable=self.optimizer_var, value=&quot;quantum_hw&quot;).grid(row=0, column=2, sticky=tk.W, padx=(20, 0), pady=5)&#10;&#10;        # 최적화 실행 버튼&#10;        button_frame = ttk.Frame(main_frame)&#10;        button_frame.grid(row=4, column=0, columnspan=2, pady=20)&#10;&#10;        self.optimize_button = ttk.Button(&#10;            button_frame,&#10;            text=&quot;포트폴리오 최적화 실행&quot;,&#10;            command=self.run_optimization,&#10;            style=&quot;Accent.TButton&quot;&#10;        )&#10;        self.optimize_button.grid(row=0, column=0, padx=10)&#10;&#10;        ttk.Button(button_frame, text=&quot;결과 저장&quot;, command=self.save_results).grid(row=0, column=1, padx=10)&#10;        ttk.Button(button_frame, text=&quot;차트 보기&quot;, command=self.show_chart).grid(row=0, column=2, padx=10)&#10;&#10;        # 진행 상황 표시&#10;        self.progress_var = tk.StringVar(value=&quot;대기 중...&quot;)&#10;        progress_label = ttk.Label(main_frame, textvariable=self.progress_var, font=(&quot;Arial&quot;, 10))&#10;        progress_label.grid(row=5, column=0, columnspan=2, pady=10)&#10;&#10;        self.progress_bar = ttk.Progressbar(main_frame, mode='indeterminate')&#10;        self.progress_bar.grid(row=6, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 20))&#10;&#10;        # 결과 표시 영역&#10;        result_frame = ttk.LabelFrame(main_frame, text=&quot;최적화 결과&quot;, padding=&quot;15&quot;)&#10;        result_frame.grid(row=7, column=0, columnspan=2, sticky=(tk.W, tk.E, tk.N, tk.S), pady=(0, 20))&#10;&#10;        # 결과 텍스트 위젯 (스크롤 가능)&#10;        text_frame = ttk.Frame(result_frame)&#10;        text_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))&#10;&#10;        self.result_text = tk.Text(text_frame, height=15, width=70, font=(&quot;Consolas&quot;, 10))&#10;        scrollbar = ttk.Scrollbar(text_frame, orient=&quot;vertical&quot;, command=self.result_text.yview)&#10;        self.result_text.configure(yscrollcommand=scrollbar.set)&#10;&#10;        self.result_text.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))&#10;        scrollbar.grid(row=0, column=1, sticky=(tk.N, tk.S))&#10;&#10;        # 그리드 가중치 설정&#10;        self.root.columnconfigure(0, weight=1)&#10;        self.root.rowconfigure(0, weight=1)&#10;        main_frame.columnconfigure(1, weight=1)&#10;        main_frame.rowconfigure(7, weight=1)&#10;        investment_frame.columnconfigure(1, weight=1)&#10;        json_frame.columnconfigure(1, weight=1)&#10;        result_frame.columnconfigure(0, weight=1)&#10;        result_frame.rowconfigure(0, weight=1)&#10;        text_frame.columnconfigure(0, weight=1)&#10;        text_frame.rowconfigure(0, weight=1)&#10;&#10;        # 초기 메시지 표시&#10;        self.display_welcome_message()&#10;&#10;    def display_welcome_message(self):&#10;        &quot;&quot;&quot;환영 메시지 표시&quot;&quot;&quot;&#10;        welcome_msg = &quot;&quot;&quot;&#10; Stock AI 포트폴리오 최적화 시스템에 오신 것을 환영합니다!&#10;&#10; 기능:&#10;• 클래식 최적화: 전통적인 평균-분산 최적화&#10;• 양자 최적화: 최신 양자 컴퓨팅 기술 활용&#10;• 실시간 주식 데이터 수집 및 분석&#10;• 포트폴리오 성과 시각화&#10;&#10; 사용 방법:&#10;1. 투자 금액을 입력하세요&#10;2. 주식 선택 방법을 선택하세요&#10;3. 최적화 방법을 선택하세요&#10;4. '포트폴리오 최적화 실행' 버튼을 클릭하세요&#10;&#10; 팁: 샘플 주식(삼성전자, SK하이닉스, 네이버, LG화학, 셀트리온)으로 먼저 테스트해보세요!&#10;&quot;&quot;&quot;&#10;        self.result_text.delete(1.0, tk.END)&#10;        self.result_text.insert(tk.END, welcome_msg)&#10;&#10;    def select_json_file(self):&#10;        &quot;&quot;&quot;JSON 파일 선택&quot;&quot;&quot;&#10;        filename = filedialog.askopenfilename(&#10;            title=&quot;주식 리스트 JSON 파일 선택&quot;,&#10;            filetypes=[(&quot;JSON files&quot;, &quot;*.json&quot;), (&quot;All files&quot;, &quot;*.*&quot;)]&#10;        )&#10;        if filename:&#10;            self.json_file_var.set(filename)&#10;&#10;    def get_stock_list(self):&#10;        &quot;&quot;&quot;선택된 방법에 따라 주식 리스트 반환&quot;&quot;&quot;&#10;        method = self.stock_method_var.get()&#10;&#10;        if method == &quot;sample&quot;:&#10;            return [&quot;005930&quot;, &quot;000660&quot;, &quot;035420&quot;, &quot;051910&quot;, &quot;068270&quot;]  # 샘플 주식&#10;        elif method == &quot;manual&quot;:&#10;            stocks_str = self.stocks_var.get().strip()&#10;            if not stocks_str:&#10;                raise ValueError(&quot;주식 코드를 입력해주세요.&quot;)&#10;            return [s.strip() for s in stocks_str.split(',')]&#10;        elif method == &quot;json&quot;:&#10;            json_file = self.json_file_var.get().strip()&#10;            if not json_file:&#10;                raise ValueError(&quot;JSON 파일을 선택해주세요.&quot;)&#10;            return json_file&#10;        else:&#10;            raise ValueError(&quot;올바른 주식 선택 방법을 선택해주세요.&quot;)&#10;&#10;    def validate_inputs(self):&#10;        &quot;&quot;&quot;입력값 검증&quot;&quot;&quot;&#10;        try:&#10;            amount = int(self.amount_var.get().replace(',', ''))&#10;            if amount &lt;= 0:&#10;                raise ValueError(&quot;투자 금액은 0보다 커야 합니다.&quot;)&#10;        except ValueError:&#10;            raise ValueError(&quot;올바른 투자 금액을 입력해주세요.&quot;)&#10;&#10;        stock_list = self.get_stock_list()&#10;        return amount, stock_list&#10;&#10;    def run_optimization(self):&#10;        &quot;&quot;&quot;최적화 실행 (별도 스레드에서)&quot;&quot;&quot;&#10;        try:&#10;            # 입력값 검증&#10;            amount, stock_list = self.validate_inputs()&#10;&#10;            # UI 업데이트&#10;            self.optimize_button.config(state=&quot;disabled&quot;)&#10;            self.progress_bar.start()&#10;            self.progress_var.set(&quot;최적화 진행 중...&quot;)&#10;            self.result_text.delete(1.0, tk.END)&#10;            self.result_text.insert(tk.END, &quot; 포트폴리오 최적화를 시작합니다...\n\n&quot;)&#10;&#10;            # 별도 스레드에서 최적화 실행&#10;            threading.Thread(&#10;                target=self.optimize_portfolio,&#10;                args=(amount, stock_list),&#10;                daemon=True&#10;            ).start()&#10;&#10;        except Exception as e:&#10;            messagebox.showerror(&quot;입력 오류&quot;, str(e))&#10;&#10;    def optimize_portfolio(self, amount, stock_list):&#10;        &quot;&quot;&quot;실제 최적화 실행&quot;&quot;&quot;&#10;        try:&#10;            if not OPTIMIZER_AVAILABLE:&#10;                raise Exception(&quot;Optimizer 모듈을 찾을 수 없습니다.&quot;)&#10;&#10;            optimizer_type = self.optimizer_var.get()&#10;&#10;            # 진행 상황 업데이트&#10;            self.root.after(0, lambda: self.update_progress(&quot;데이터 수집 중...&quot;))&#10;&#10;            print(f&quot;최적화 시작 - 방법: {optimizer_type}, 금액: {amount}, 주식: {stock_list}&quot;)&#10;&#10;            result = None&#10;            if optimizer_type == &quot;classic&quot;:&#10;                # 클래식 최적화&#10;                if isinstance(stock_list, str):  # JSON 파일인 경우&#10;                    from classic_opt import optimize_portfolio_from_json&#10;                    result = optimize_portfolio_from_json(stock_list, amount)&#10;                else:&#10;                    optimizer = PortfolioOptimizer(stock_list, amount)&#10;                    result = optimizer.run_optimization()&#10;&#10;            else:&#10;                # 양자 최적화&#10;                use_hardware = (optimizer_type == &quot;quantum_hw&quot;)&#10;&#10;                if isinstance(stock_list, str):  # JSON 파일인 경우&#10;                    from quantum_opt import optimize_quantum_portfolio_from_json&#10;                    result = optimize_quantum_portfolio_from_json(stock_list, amount, use_real_quantum=use_hardware)&#10;                else:&#10;                    optimizer = QuantumPortfolioOptimizer(stock_list, amount, use_real_quantum=use_hardware)&#10;                    result = optimizer.run_optimization()&#10;&#10;            # 결과 처리&#10;            print(f&quot;최적화 결과: {result is not None}&quot;)&#10;            if result:&#10;                print(f&quot;결과 키들: {list(result.keys()) if isinstance(result, dict) else 'Not a dict'}&quot;)&#10;                # 스레드 안전한 방식으로 결과 업데이트&#10;                self.result_data = result&#10;                # GUI 업데이트는 메인 스레드에서 실행되도록 예약&#10;                self.root.after(100, lambda: self.display_results_safe(result))&#10;            else:&#10;                print(&quot;결과가 None입니다.&quot;)&#10;                self.root.after(100, lambda: self.show_error(&quot;최적화에 실패했습니다. 콘솔을 확인해주세요.&quot;))&#10;&#10;        except Exception as e:&#10;            print(f&quot;최적화 중 예외 발생: {e}&quot;)&#10;            import traceback&#10;            print(f&quot;상세 오류:\n{traceback.format_exc()}&quot;)&#10;            self.root.after(100, lambda: self.show_error(f&quot;오류 발생: {str(e)}&quot;))&#10;        finally:&#10;            # UI 복원&#10;            self.root.after(200, self.reset_ui)&#10;&#10;    def update_progress(self, message):&#10;        &quot;&quot;&quot;진행 상황 업데이트&quot;&quot;&quot;&#10;        self.progress_var.set(message)&#10;        self.result_text.insert(tk.END, f&quot; {message}\n&quot;)&#10;        self.result_text.see(tk.END)&#10;&#10;    def display_results_safe(self, result):&#10;        &quot;&quot;&quot;스레드 안전한 결과 표시&quot;&quot;&quot;&#10;        try:&#10;            print(&quot;GUI에서 결과 표시 시작&quot;)&#10;            self.display_results(result)&#10;            print(&quot;GUI에서 결과 표시 완료&quot;)&#10;        except Exception as e:&#10;            print(f&quot;결과 표시 중 오류: {e}&quot;)&#10;            import traceback&#10;            print(f&quot;상세 오류:\n{traceback.format_exc()}&quot;)&#10;            self.show_error(f&quot;결과 표시 중 오류: {str(e)}&quot;)&#10;&#10;    def display_results(self, result):&#10;        &quot;&quot;&quot;결과 표시&quot;&quot;&quot;&#10;        print(&quot;display_results 호출됨&quot;)&#10;        try:&#10;            self.result_text.delete(1.0, tk.END)&#10;&#10;            # 결과 데이터 검증&#10;            if not isinstance(result, dict):&#10;                raise ValueError(&quot;결과가 딕셔너리 형태가 아닙니다.&quot;)&#10;&#10;            if 'performance' not in result:&#10;                raise ValueError(&quot;성과 데이터가 없습니다.&quot;)&#10;&#10;            if 'allocations' not in result:&#10;                raise ValueError(&quot;배분 데이터가 없습니다.&quot;)&#10;&#10;            # 성과 요약&#10;            perf = result['performance']&#10;            method = result.get('method', '알 수 없음')&#10;&#10;            result_msg = f&quot;&quot;&quot;&#10;✅ 포트폴리오 최적화 완료!&#10;&#10; 최적화 방법: {method}&#10; 성과 요약:&#10;  • 예상 연간 수익률: {perf['expected_return']:.2%}&#10;  • 예상 연간 변동성: {perf['volatility']:.2%}&#10;  • 샤프 비율: {perf['sharpe_ratio']:.3f}&#10;&#10; 투자 배분:&#10;&quot;&quot;&quot;&#10;&#10;            # 배분 정보 추가&#10;            allocations = result['allocations']&#10;            print(f&quot;배분 데이터 개수: {len(allocations)}&quot;)&#10;&#10;            for i, allocation in enumerate(allocations[:10]):  # 상위 10개만 표시&#10;                if allocation.get('weight', 0) &gt; 0.001:  # 0.1% 이상만 표시&#10;                    symbol = allocation.get('symbol', 'Unknown')&#10;                    amount = allocation.get('amount', 0)&#10;                    percentage = allocation.get('percentage', 0)&#10;                    result_msg += f&quot;  {i+1:2d}. {symbol}: {amount:,}원 ({percentage:.1f}%)\n&quot;&#10;&#10;            if 'chart_file' in result:&#10;                result_msg += f&quot;\n 차트 파일: {result['chart_file']}&quot;&#10;&#10;            if 'backend_info' in result:&#10;                backend = result['backend_info']&#10;                result_msg += f&quot;\n️ 백엔드: {backend['name']} ({backend['type']})&quot;&#10;&#10;            result_msg += f&quot;\n\n⏰ 완료 시간: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}&quot;&#10;&#10;            # 텍스트 위젯에 결과 표시&#10;            self.result_text.insert(tk.END, result_msg)&#10;            self.result_text.see(tk.END)  # 마지막으로 스크롤&#10;&#10;            # 상태 업데이트&#10;            self.progress_var.set(&quot;최적화 완료!&quot;)&#10;&#10;            print(&quot;결과 표시 완료&quot;)&#10;&#10;        except Exception as e:&#10;            print(f&quot;결과 표시 중 내부 오류: {e}&quot;)&#10;            import traceback&#10;            print(f&quot;상세 오류:\n{traceback.format_exc()}&quot;)&#10;            self.show_error(f&quot;결과 표시 오류: {str(e)}&quot;)&#10;&#10;    def show_error(self, error_msg):&#10;        &quot;&quot;&quot;오류 메시지 표시&quot;&quot;&quot;&#10;        self.result_text.delete(1.0, tk.END)&#10;        self.result_text.insert(tk.END, f&quot;❌ {error_msg}&quot;)&#10;        self.progress_var.set(&quot;오류 발생&quot;)&#10;        messagebox.showerror(&quot;오류&quot;, error_msg)&#10;&#10;    def reset_ui(self):&#10;        &quot;&quot;&quot;UI 상태 복원&quot;&quot;&quot;&#10;        self.optimize_button.config(state=&quot;normal&quot;)&#10;        self.progress_bar.stop()&#10;        if not hasattr(self, 'result_data') or self.result_data is None:&#10;            self.progress_var.set(&quot;대기 중...&quot;)&#10;&#10;    def save_results(self):&#10;        &quot;&quot;&quot;결과 저장&quot;&quot;&quot;&#10;        if not hasattr(self, 'result_data') or self.result_data is None:&#10;            messagebox.showwarning(&quot;경고&quot;, &quot;저장할 결과가 없습니다.&quot;)&#10;            return&#10;&#10;        try:&#10;            filename = filedialog.asksaveasfilename(&#10;                title=&quot;결과 저장&quot;,&#10;                defaultextension=&quot;.txt&quot;,&#10;                filetypes=[(&quot;Text files&quot;, &quot;*.txt&quot;), (&quot;All files&quot;, &quot;*.*&quot;)]&#10;            )&#10;&#10;            if filename:&#10;                with open(filename, 'w', encoding='utf-8') as f:&#10;                    f.write(self.result_text.get(1.0, tk.END))&#10;                messagebox.showinfo(&quot;성공&quot;, f&quot;결과가 저장되었습니다: {filename}&quot;)&#10;        except Exception as e:&#10;            messagebox.showerror(&quot;오류&quot;, f&quot;저장 중 오류 발생: {str(e)}&quot;)&#10;&#10;    def show_chart(self):&#10;        &quot;&quot;&quot;차트 및 상세 결과 창 표시&quot;&quot;&quot;&#10;        if not hasattr(self, 'result_data') or self.result_data is None:&#10;            messagebox.showwarning(&quot;경고&quot;, &quot;표시할 차트가 없습니다.&quot;)&#10;            return&#10;&#10;        # 새 창 생성&#10;        chart_window = tk.Toplevel(self.root)&#10;        chart_window.title(&quot;포트폴리오 분석 결과&quot;)&#10;        chart_window.geometry(&quot;1200x800&quot;)&#10;        chart_window.configure(bg='#f0f0f0')&#10;&#10;        # 메인 프레임&#10;        main_frame = ttk.Frame(chart_window, padding=&quot;10&quot;)&#10;        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))&#10;&#10;        # 창 크기 조절 가능하도록 설정&#10;        chart_window.columnconfigure(0, weight=1)&#10;        chart_window.rowconfigure(0, weight=1)&#10;        main_frame.columnconfigure(0, weight=1)&#10;        main_frame.rowconfigure(1, weight=1)&#10;&#10;        # 제목&#10;        title_label = tk.Label(&#10;            main_frame,&#10;            text=&quot;�� 포트폴리오 분석 결과&quot;,&#10;            font=(&quot;Arial&quot;, 18, &quot;bold&quot;),&#10;            bg='#f0f0f0',&#10;            fg='#2c3e50'&#10;        )&#10;        title_label.grid(row=0, column=0, pady=(0, 20))&#10;&#10;        # 노트북 (탭) 위젯 생성&#10;        notebook = ttk.Notebook(main_frame)&#10;        notebook.grid(row=1, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))&#10;&#10;        # 탭 1: 차트 이미지&#10;        chart_frame = ttk.Frame(notebook, padding=&quot;10&quot;)&#10;        notebook.add(chart_frame, text=&quot; 포트폴리오 차트&quot;)&#10;&#10;        # 탭 2: 상세 결과&#10;        details_frame = ttk.Frame(notebook, padding=&quot;10&quot;)&#10;        notebook.add(details_frame, text=&quot; 상세 분석&quot;)&#10;&#10;        # 탭 3: 투자 배분&#10;        allocation_frame = ttk.Frame(notebook, padding=&quot;10&quot;)&#10;        notebook.add(allocation_frame, text=&quot; 투자 배분&quot;)&#10;&#10;        # 차트 이미지 표시&#10;        self.display_chart_image(chart_frame)&#10;&#10;        # 상세 결과 표시&#10;        self.display_detailed_results(details_frame)&#10;&#10;        # 투자 배분 표시&#10;        self.display_allocation_table(allocation_frame)&#10;&#10;    def display_chart_image(self, parent_frame):&#10;        &quot;&quot;&quot;차트 이미지 표시&quot;&quot;&quot;&#10;        chart_file = self.result_data.get('chart_file')&#10;&#10;        if chart_file and os.path.exists(chart_file):&#10;            try:&#10;                # 이미지 로드 및 크기 조정&#10;                image = Image.open(chart_file)&#10;&#10;                # 창 크기에 맞게 이미지 크기 조정&#10;                display_size = (1000, 600)&#10;                image.thumbnail(display_size, Image.Resampling.LANCZOS)&#10;&#10;                photo = ImageTk.PhotoImage(image)&#10;&#10;                # 스크롤 가능한 프레임 생성&#10;                canvas = tk.Canvas(parent_frame, bg='white')&#10;                scrollbar_v = ttk.Scrollbar(parent_frame, orient=&quot;vertical&quot;, command=canvas.yview)&#10;                scrollbar_h = ttk.Scrollbar(parent_frame, orient=&quot;horizontal&quot;, command=canvas.xview)&#10;&#10;                canvas.configure(yscrollcommand=scrollbar_v.set, xscrollcommand=scrollbar_h.set)&#10;&#10;                # 이미지 표시&#10;                image_label = tk.Label(canvas, image=photo, bg='white')&#10;                image_label.image = photo  # 참조 유지&#10;&#10;                canvas.create_window(0, 0, anchor=&quot;nw&quot;, window=image_label)&#10;                canvas.update_idletasks()&#10;                canvas.configure(scrollregion=canvas.bbox(&quot;all&quot;))&#10;&#10;                # 그리드 배치&#10;                canvas.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))&#10;                scrollbar_v.grid(row=0, column=1, sticky=(tk.N, tk.S))&#10;                scrollbar_h.grid(row=1, column=0, sticky=(tk.W, tk.E))&#10;&#10;                # 그리드 가중치&#10;                parent_frame.columnconfigure(0, weight=1)&#10;                parent_frame.rowconfigure(0, weight=1)&#10;&#10;            except Exception as e:&#10;                error_label = tk.Label(&#10;                    parent_frame,&#10;                    text=f&quot;❌ 차트 이미지를 로드할 수 없습니다:\n{str(e)}&quot;,&#10;                    font=(&quot;Arial&quot;, 12),&#10;                    fg='red',&#10;                    justify=tk.CENTER&#10;                )&#10;                error_label.grid(row=0, column=0, padx=20, pady=20)&#10;        else:&#10;            no_chart_label = tk.Label(&#10;                parent_frame,&#10;                text=&quot; 차트 파일을 찾을 수 없습니다.&quot;,&#10;                font=(&quot;Arial&quot;, 14),&#10;                fg='gray',&#10;                justify=tk.CENTER&#10;            )&#10;            no_chart_label.grid(row=0, column=0, padx=20, pady=20)&#10;&#10;    def display_detailed_results(self, parent_frame):&#10;        &quot;&quot;&quot;상세 결과 표시&quot;&quot;&quot;&#10;        # 스크롤 가능한 텍스트 위젯&#10;        text_frame = ttk.Frame(parent_frame)&#10;        text_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))&#10;&#10;        text_widget = tk.Text(text_frame, font=(&quot;Consolas&quot;, 11), wrap=tk.WORD)&#10;        scrollbar = ttk.Scrollbar(text_frame, orient=&quot;vertical&quot;, command=text_widget.yview)&#10;        text_widget.configure(yscrollcommand=scrollbar.set)&#10;&#10;        # 상세 정보 텍스트 생성&#10;        perf = self.result_data['performance']&#10;        method = self.result_data.get('method', '알 수 없음')&#10;&#10;        detailed_text = f&quot;&quot;&quot;&#10; 포트폴리오 최적화 상세 결과&#10;{'=' * 50}&#10;&#10; 최적화 방법: {method}&#10;&#10; 포트폴리오 성과 지표:&#10;  • 예상 연간 수익률: {perf['expected_return']:.4%}&#10;  • 예상 연간 변동성: {perf['volatility']:.4%}&#10;  • 샤프 비율: {perf['sharpe_ratio']:.6f}&#10;  • 위험 대비 수익률: {perf['expected_return']/perf['volatility']:.4f}&#10;&#10; 투자 총액: {sum(allocation['amount'] for allocation in self.result_data['allocations']):,}원&#10;&#10; 전체 종목별 투자 배분:&#10;{'=' * 50}&#10;&quot;&quot;&quot;&#10;&#10;        # 모든 배분 정보 추가&#10;        for i, allocation in enumerate(self.result_data['allocations'], 1):&#10;            if allocation['weight'] &gt; 0.0001:  # 0.01% 이상만 표시&#10;                detailed_text += f&quot;{i:3d}. {allocation['symbol']:8s} | &quot;&#10;                detailed_text += f&quot;{allocation['name'][:20]:20s} | &quot;&#10;                detailed_text += f&quot;{allocation['amount']:&gt;12,}원 | &quot;&#10;                detailed_text += f&quot;{allocation['percentage']:&gt;6.2f}% | &quot;&#10;                detailed_text += f&quot;가중치: {allocation['weight']:.4f}\n&quot;&#10;&#10;        # 백엔드 정보 추가&#10;        if 'backend_info' in self.result_data:&#10;            backend = self.result_data['backend_info']&#10;            detailed_text += f&quot;&quot;&quot;&#10;&#10;️ 백엔드 정보:&#10;{'=' * 50}&#10;  • 백엔드 이름: {backend['name']}&#10;  • 백엔드 타입: {backend['type']}&#10;&quot;&quot;&quot;&#10;&#10;        # 차트 파일 정보 추가&#10;        if 'chart_file' in self.result_data:&#10;            detailed_text += f&quot;&quot;&quot;&#10;&#10; 차트 파일:&#10;{'=' * 50}&#10;  • 파일 경로: {self.result_data['chart_file']}&#10;  • 파일 존재: {'✅' if os.path.exists(self.result_data['chart_file']) else '❌'}&#10;&quot;&quot;&quot;&#10;&#10;        detailed_text += f&quot;&quot;&quot;&#10;&#10;⏰ 분석 완료 시간: {datetime.now().strftime('%Y년 %m월 %d일 %H시 %M분 %S초')}&#10;&#10; 참고사항:&#10;  • 이 결과는 과거 데이터를 기반으로 한 예측이며, 실제 수익을 보장하지 않습니다.&#10;  • 투자 결정 시 충분한 검토와 전문가 상담을 권장합니다.&#10;  • 포트폴리오는 정기적으로 재조정하는 것이 좋습니다.&#10;&quot;&quot;&quot;&#10;&#10;        # 텍스트 삽입&#10;        text_widget.insert(tk.END, detailed_text)&#10;        text_widget.config(state=tk.DISABLED)  # 읽기 전용으로 설정&#10;&#10;        # 위젯 배치&#10;        text_widget.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))&#10;        scrollbar.grid(row=0, column=1, sticky=(tk.N, tk.S))&#10;&#10;        # 그리드 가중치 설정&#10;        parent_frame.columnconfigure(0, weight=1)&#10;        parent_frame.rowconfigure(0, weight=1)&#10;        text_frame.columnconfigure(0, weight=1)&#10;        text_frame.rowconfigure(0, weight=1)&#10;&#10;    def display_allocation_table(self, parent_frame):&#10;        &quot;&quot;&quot;투자 배분 테이블 표시&quot;&quot;&quot;&#10;        # 테이블 프레임&#10;        table_frame = ttk.Frame(parent_frame)&#10;        table_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))&#10;&#10;        # 트리뷰 위젯 생성 (테이블)&#10;        columns = ('순위', '종목코드', '종목명', '투자금액', '비중(%)', '가중치')&#10;        tree = ttk.Treeview(table_frame, columns=columns, show='headings', height=15)&#10;&#10;        # 헤더 설정&#10;        tree.heading('순위', text='순위')&#10;        tree.heading('종목코드', text='종목코드')&#10;        tree.heading('종목명', text='종목명')&#10;        tree.heading('투자금액', text='투자금액(원)')&#10;        tree.heading('비중(%)', text='비중(%)')&#10;        tree.heading('가중치', text='가중치')&#10;&#10;        # 컬럼 너비 설정&#10;        tree.column('순위', width=50, anchor='center')&#10;        tree.column('종목코드', width=80, anchor='center')&#10;        tree.column('종목명', width=200, anchor='w')&#10;        tree.column('투자금액', width=120, anchor='e')&#10;        tree.column('비중(%)', width=80, anchor='e')&#10;        tree.column('가중치', width=100, anchor='e')&#10;&#10;        # 스크롤바 추가&#10;        scrollbar_table = ttk.Scrollbar(table_frame, orient=&quot;vertical&quot;, command=tree.yview)&#10;        tree.configure(yscrollcommand=scrollbar_table.set)&#10;&#10;        # 데이터 삽입&#10;        for i, allocation in enumerate(self.result_data['allocations'], 1):&#10;            if allocation['weight'] &gt; 0.0001:  # 0.01% 이상만 표시&#10;                tree.insert('', 'end', values=(&#10;                    i,&#10;                    allocation['symbol'],&#10;                    allocation['name'][:25],  # 이름 길이 제한&#10;                    f&quot;{allocation['amount']:,}&quot;,&#10;                    f&quot;{allocation['percentage']:.2f}&quot;,&#10;                    f&quot;{allocation['weight']:.4f}&quot;&#10;                ))&#10;&#10;        # 위젯 배치&#10;        tree.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))&#10;        scrollbar_table.grid(row=0, column=1, sticky=(tk.N, tk.S))&#10;&#10;        # 요약 정보 프레임&#10;        summary_frame = ttk.LabelFrame(parent_frame, text=&quot;포트폴리오 요약&quot;, padding=&quot;10&quot;)&#10;        summary_frame.grid(row=1, column=0, sticky=(tk.W, tk.E), pady=(10, 0))&#10;&#10;        # 요약 정보 레이블들&#10;        perf = self.result_data['performance']&#10;        total_amount = sum(allocation['amount'] for allocation in self.result_data['allocations'])&#10;        active_stocks = len([a for a in self.result_data['allocations'] if a['weight'] &gt; 0.0001])&#10;&#10;        summary_info = [&#10;            f&quot; 총 투자 금액: {total_amount:,}원&quot;,&#10;            f&quot; 활성 종목 수: {active_stocks}개&quot;,&#10;            f&quot; 예상 연간 수익률: {perf['expected_return']:.2%}&quot;,&#10;            f&quot; 예상 연간 변동성: {perf['volatility']:.2%}&quot;,&#10;            f&quot;⚡ 샤프 비율: {perf['sharpe_ratio']:.3f}&quot;&#10;        ]&#10;&#10;        for i, info in enumerate(summary_info):&#10;            label = ttk.Label(summary_frame, text=info, font=(&quot;Arial&quot;, 10))&#10;            label.grid(row=i//2, column=i%2, sticky=tk.W, padx=10, pady=2)&#10;&#10;        # 그리드 가중치 설정&#10;        parent_frame.columnconfigure(0, weight=1)&#10;        parent_frame.rowconfigure(0, weight=1)&#10;        table_frame.columnconfigure(0, weight=1)&#10;        table_frame.rowconfigure(0, weight=1)&#10;        summary_frame.columnconfigure(0, weight=1)&#10;        summary_frame.columnconfigure(1, weight=1)&#10;&#10;&#10;def main():&#10;    &quot;&quot;&quot;메인 함수&quot;&quot;&quot;&#10;    root = tk.Tk()&#10;    app = StockAIGUI(root)&#10;&#10;    # 스타일 설정&#10;    style = ttk.Style()&#10;    style.theme_use('clam')&#10;&#10;    # 애플리케이션 실행&#10;    root.mainloop()&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/_1st_stage_news_analysis_LLM.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/_1st_stage_news_analysis_LLM.py" />
              <option name="updatedContent" value="import time&#10;from typing import Optional&#10;from dotenv import load_dotenv&#10;import os&#10;import re&#10;import json&#10;load_dotenv()&#10;&#10;from google import genai&#10;from google.genai import types&#10;&#10;model_name = &quot;gemini-2.0-flash-001&quot;&#10;&#10;# .env 파일에서 API 키 로드 (보안 강화)&#10;client = genai.Client(api_key=os.getenv(&quot;GOOGLE_AI_API_KEY&quot;))&#10;&#10;def ask_question_to_gemini_cache(prompt, max_retries=5, retry_delay=5):&#10;    &quot;&quot;&quot;&#10;    Gemini API를 사용하여 질문에 대한 답변을 얻습니다.&#10;    뉴스 분석에 최적화된 버전입니다.&#10;    &quot;&quot;&quot;&#10;    start_time = time.time()&#10;&#10;    for attempt in range(max_retries):&#10;        try:&#10;            # API 키 확인&#10;            api_key = os.getenv(&quot;GOOGLE_AI_API_KEY&quot;)&#10;            if not api_key:&#10;                raise Exception(&quot;GOOGLE_AI_API_KEY 환경 변수가 설정되지 않았습니다.&quot;)&#10;&#10;            api_start = time.time()&#10;&#10;            # Gemini API 호출&#10;            response = client.models.generate_content(&#10;                model=model_name,&#10;                contents=prompt,&#10;                config=types.GenerateContentConfig(&#10;                    temperature=0.3,&#10;                    max_output_tokens=2048&#10;                )&#10;            )&#10;&#10;            return response.text&#10;&#10;        except Exception as e:&#10;            error_msg = str(e).lower()&#10;            print(f&quot;API 오류 (시도 {attempt + 1}/{max_retries}): {e}&quot;)&#10;&#10;            if hasattr(e, 'code') and e.code == 503:&#10;                print(f&quot;⏳ API 사용량 한도 초과 (시도 {attempt + 1}/{max_retries}). {retry_delay}초 후 재시도...&quot;)&#10;                time.sleep(retry_delay)&#10;                retry_delay *= 2  # 지수적 백오프&#10;                continue&#10;&#10;            if attempt == max_retries - 1:&#10;                raise Exception(f&quot;최대 재시도 횟수 초과. 마지막 오류: {e}&quot;)&#10;&#10;            time.sleep(retry_delay)&#10;&#10;    raise Exception(&quot;모든 재시도 실패&quot;)&#10;&#10;def json_match(text):&#10;    &quot;&quot;&quot;&#10;    텍스트에서 JSON 객체를 추출하는 함수&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # 중괄호 패턴 매칭&#10;        pattern = r'\{[^{}]*(?:\{[^{}]*\}[^{}]*)*\}'&#10;        matches = re.findall(pattern, text, re.DOTALL)&#10;        &#10;        for match in matches:&#10;            try:&#10;                return json.loads(match)&#10;            except json.JSONDecodeError:&#10;                continue&#10;        &#10;        # 백틱으로 감싸진 JSON 찾기&#10;        json_pattern = r'```(?:json)?\s*(\{.*?\})\s*```'&#10;        matches = re.findall(json_pattern, text, re.DOTALL)&#10;        &#10;        for match in matches:&#10;            try:&#10;                return json.loads(match)&#10;            except json.JSONDecodeError:&#10;                continue&#10;        &#10;        return None&#10;    except Exception as e:&#10;        print(f&quot;JSON 파싱 오류: {e}&quot;)&#10;        return None&#10;&#10;def create_news_analysis_prompt(news_text):&#10;    &quot;&quot;&quot;뉴스 분석용 프롬프트 생성&quot;&quot;&quot;&#10;    return f&quot;&quot;&quot;&#10;다음 뉴스들을 분석하여 JSON 형태로 결과를 제공해주세요:&#10;&#10;{news_text}&#10;&#10;분석 결과를 다음 JSON 형식으로 정확히 제공해주세요:&#10;&#10;{{&#10;  &quot;overall_sentiment&quot;: &quot;positive/negative/neutral&quot;,&#10;  &quot;sentiment_score&quot;: 0-100,&#10;  &quot;key_themes&quot;: [&quot;주요 테마1&quot;, &quot;주요 테마2&quot;],&#10;  &quot;market_impact&quot;: &quot;시장에 미치는 영향 분석&quot;,&#10;  &quot;summary&quot;: &quot;전체 뉴스 요약&quot;,&#10;  &quot;investment_signals&quot;: &quot;buy/sell/hold&quot;&#10;}}&#10;&quot;&quot;&quot;&#10;&#10;def create_research_reports_analysis_prompt(reports_text):&#10;    &quot;&quot;&quot;리서치 리포트 분석용 프롬프트 생성&quot;&quot;&quot;&#10;    return f&quot;&quot;&quot;&#10;다음 리서치 리포트들을 분석하여 JSON 형태로 결과를 제공해주세요:&#10;&#10;{reports_text}&#10;&#10;분석 결과를 다음 JSON 형식으로 정확히 제공해주세요:&#10;&#10;{{&#10;  &quot;category_summary&quot;: {{&#10;    &quot;종목분석&quot;: &quot;종목분석 요약&quot;,&#10;    &quot;산업분석&quot;: &quot;산업분석 요약&quot;,&#10;    &quot;시황정보&quot;: &quot;시황정보 요약&quot;,&#10;    &quot;투자정보&quot;: &quot;투자정보 요약&quot;&#10;  }},&#10;  &quot;top_mentioned_stocks&quot;: [&quot;종목1&quot;, &quot;종목2&quot;, &quot;종목3&quot;],&#10;  &quot;key_industries&quot;: [&quot;업종1&quot;, &quot;업종2&quot;, &quot;업종3&quot;],&#10;  &quot;investment_themes&quot;: [&quot;투자테마1&quot;, &quot;투자테마2&quot;],&#10;  &quot;market_outlook&quot;: &quot;positive/negative/neutral&quot;,&#10;  &quot;risk_factors&quot;: [&quot;리스크1&quot;, &quot;리스크2&quot;],&#10;  &quot;opportunities&quot;: [&quot;기회1&quot;, &quot;기회2&quot;],&#10;  &quot;analyst_consensus&quot;: &quot;애널리스트 consensus&quot;,&#10;  &quot;summary&quot;: &quot;전체 리포트 종합 요약&quot;&#10;}}&#10;&quot;&quot;&quot;&#10;&#10;def create_individual_news_analysis_prompt(news_article):&#10;    &quot;&quot;&quot;개별 뉴스 분석용 프롬프트 생성&quot;&quot;&quot;&#10;    return f&quot;&quot;&quot;&#10;다음 뉴스 기사를 분석하여 JSON 형태로 결과를 제공해주세요:&#10;&#10;제목: {news_article.get('title', '')}&#10;내용: {news_article.get('content', '')[:1000]}...&#10;&#10;분석 결과를 다음 JSON 형식으로 정확히 제공해주세요:&#10;&#10;{{&#10;  &quot;sentiment&quot;: &quot;positive/negative/neutral&quot;,&#10;  &quot;confidence&quot;: 0.0-1.0,&#10;  &quot;key_points&quot;: [&quot;핵심 포인트1&quot;, &quot;핵심 포인트2&quot;],&#10;  &quot;mentioned_companies&quot;: [&quot;언급된 회사1&quot;, &quot;언급된 회사2&quot;],&#10;  &quot;market_impact&quot;: &quot;high/medium/low&quot;,&#10;  &quot;investment_signal&quot;: &quot;buy/sell/hold&quot;,&#10;  &quot;summary&quot;: &quot;기사 요약&quot;&#10;}}&#10;&quot;&quot;&quot;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/debug_crawler.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/debug_crawler.py" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;네이버 증권 크롤링 디버깅용 스크립트&#10;실제 페이지 구조를 확인하여 문제점을 파악합니다.&#10;&quot;&quot;&quot;&#10;&#10;import requests&#10;from bs4 import BeautifulSoup&#10;import json&#10;&#10;def debug_research_page():&#10;    &quot;&quot;&quot;메인 리서치 페이지 구조 분석&quot;&quot;&quot;&#10;    url = &quot;https://finance.naver.com/research/&quot;&#10;    headers = {&#10;        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'&#10;    }&#10;    &#10;    try:&#10;        response = requests.get(url, headers=headers)&#10;        response.raise_for_status()&#10;        &#10;        soup = BeautifulSoup(response.content, 'html.parser')&#10;        &#10;        print(&quot;=== 네이버 증권 리서치 페이지 구조 분석 ===&quot;)&#10;        &#10;        # 모든 box_type_m 찾기&#10;        sections = soup.find_all('div', {'class': 'box_type_m'})&#10;        print(f&quot;box_type_m 섹션 개수: {len(sections)}&quot;)&#10;        &#10;        for i, section in enumerate(sections):&#10;            print(f&quot;\n--- 섹션 {i} ---&quot;)&#10;            &#10;            # 제목 찾기&#10;            title_elem = section.find('h4', {'class': 'h_sub2'})&#10;            if title_elem:&#10;                print(f&quot;제목: {title_elem.get_text(strip=True)}&quot;)&#10;            &#10;            # 테이블 찾기&#10;            table = section.find('table', {'class': 'type_1'})&#10;            if table:&#10;                print(&quot;테이블 발견!&quot;)&#10;                &#10;                # 테이블 헤더 확인&#10;                headers = table.find_all('th')&#10;                if headers:&#10;                    header_texts = [th.get_text(strip=True) for th in headers]&#10;                    print(f&quot;헤더: {header_texts}&quot;)&#10;                &#10;                # 첫 번째 데이터 행 확인&#10;                tbody = table.find('tbody')&#10;                if tbody:&#10;                    rows = tbody.find_all('tr')&#10;                else:&#10;                    rows = table.find_all('tr')[1:]  # 헤더 제외&#10;                &#10;                if rows:&#10;                    first_row = rows[0]&#10;                    cells = first_row.find_all('td')&#10;                    if cells:&#10;                        cell_texts = [td.get_text(strip=True) for td in cells]&#10;                        print(f&quot;첫 번째 행 데이터: {cell_texts}&quot;)&#10;                        &#10;                        # 링크 확인&#10;                        for j, cell in enumerate(cells):&#10;                            link = cell.find('a')&#10;                            if link:&#10;                                print(f&quot;  셀 {j}에 링크 발견: {link.get('href')}&quot;)&#10;            else:&#10;                print(&quot;테이블 없음&quot;)&#10;        &#10;        # 전체 페이지에서 &quot;종목분석&quot; 텍스트 찾기&#10;        page_text = soup.get_text()&#10;        if &quot;종목분석&quot; in page_text:&#10;            print(f&quot;\n'종목분석' 텍스트 발견됨&quot;)&#10;        else:&#10;            print(f&quot;\n'종목분석' 텍스트 없음&quot;)&#10;            &#10;    except Exception as e:&#10;        print(f&quot;오류 발생: {e}&quot;)&#10;&#10;def debug_news_detail():&#10;    &quot;&quot;&quot;뉴스 상세 페이지 구조 분석&quot;&quot;&quot;&#10;    # 샘플 뉴스 링크 (상대 경로를 절대 경로로 변환)&#10;    base_url = &quot;https://finance.naver.com&quot;&#10;    sample_link = &quot;/news/news_read.naver?article_id=0001218141&amp;office_id=215&amp;mode=mainnews&amp;type=&amp;date=2025-07-29&amp;page=1&quot;&#10;    full_url = base_url + sample_link&#10;    &#10;    headers = {&#10;        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'&#10;    }&#10;    &#10;    try:&#10;        response = requests.get(full_url, headers=headers)&#10;        response.raise_for_status()&#10;        &#10;        soup = BeautifulSoup(response.content, 'html.parser')&#10;        &#10;        print(&quot;\n=== 뉴스 상세 페이지 구조 분석 ===&quot;)&#10;        print(f&quot;URL: {full_url}&quot;)&#10;        &#10;        # 다양한 선택자로 본문 찾기 시도&#10;        content_selectors = [&#10;            '.newsct_article',&#10;            '.articleCont', &#10;            '.news_content',&#10;            '.article_view',&#10;            '.view_text',&#10;            '#news_read'&#10;        ]&#10;        &#10;        for selector in content_selectors:&#10;            element = soup.select_one(selector)&#10;            if element:&#10;                content = element.get_text(strip=True)&#10;                print(f&quot;선택자 '{selector}' 성공 - 내용 길이: {len(content)}&quot;)&#10;                if len(content) &gt; 0:&#10;                    print(f&quot;내용 미리보기: {content[:100]}...&quot;)&#10;                    break&#10;        else:&#10;            print(&quot;본문을 찾을 수 없음&quot;)&#10;        &#10;        # 날짜 찾기 시도&#10;        date_selectors = [&#10;            '.article_info .date',&#10;            '.newsct_date',&#10;            '.news_date',&#10;            '.date_time'&#10;        ]&#10;        &#10;        for selector in date_selectors:&#10;            element = soup.select_one(selector)&#10;            if element:&#10;                date_text = element.get_text(strip=True)&#10;                print(f&quot;선택자 '{selector}' 성공 - 날짜: {date_text}&quot;)&#10;                break&#10;        else:&#10;            print(&quot;날짜를 찾을 수 없음&quot;)&#10;            &#10;    except Exception as e:&#10;        print(f&quot;뉴스 상세 페이지 오류: {e}&quot;)&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    debug_research_page()&#10;    debug_news_detail()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/diagnose_gemini.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/diagnose_gemini.py" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Gemini API 연결 진단 스크립트&#10;&quot;&quot;&quot;&#10;&#10;import os&#10;from dotenv import load_dotenv&#10;import google.generativeai as genai&#10;&#10;def diagnose_gemini_connection():&#10;    &quot;&quot;&quot;Gemini API 연결 상태를 진단합니다.&quot;&quot;&quot;&#10;    &#10;    print(&quot; Gemini API 연결 진단 시작...&quot;)&#10;    &#10;    # 1. 환경 변수 확인&#10;    load_dotenv()&#10;    api_key = os.getenv(&quot;GOOGLE_AI_API_KEY&quot;)&#10;    &#10;    if not api_key:&#10;        print(&quot;❌ GOOGLE_AI_API_KEY 환경 변수가 설정되지 않았습니다.&quot;)&#10;        print(&quot; 해결 방법:&quot;)&#10;        print(&quot;   1. .env 파일을 생성하고 다음 내용을 추가하세요:&quot;)&#10;        print(&quot;      GOOGLE_AI_API_KEY=your_actual_api_key_here&quot;)&#10;        print(&quot;   2. Google AI Studio에서 API 키를 발급받으세요: https://aistudio.google.com/app/apikey&quot;)&#10;        return False&#10;    &#10;    print(f&quot;✅ API 키 확인됨 (길이: {len(api_key)} 문자)&quot;)&#10;    &#10;    # 2. API 키 형식 확인&#10;    if not api_key.startswith('AIza'):&#10;        print(&quot;⚠️  API 키 형식이 올바르지 않을 수 있습니다. (AIza로 시작해야 함)&quot;)&#10;    &#10;    # 3. API 연결 테스트&#10;    try:&#10;        print(&quot; Gemini API 연결 테스트 중...&quot;)&#10;        genai.configure(api_key=api_key)&#10;        &#10;        # 간단한 모델 호출 테스트&#10;        model = genai.GenerativeModel(&quot;gemini-2.0-flash-001&quot;)&#10;        &#10;        print(&quot; 간단한 테스트 요청 전송 중...&quot;)&#10;        response = model.generate_content(&#10;            &quot;안녕하세요를 영어로 번역해주세요.&quot;,&#10;            generation_config=genai.types.GenerationConfig(&#10;                temperature=0.1,&#10;                max_output_tokens=50&#10;            )&#10;        )&#10;        &#10;        print(&quot;✅ API 연결 성공!&quot;)&#10;        print(f&quot; 응답: {response.text}&quot;)&#10;        &#10;        # 토큰 사용량 확인&#10;        if hasattr(response, 'usage_metadata'):&#10;            print(f&quot; 토큰 사용량: {response.usage_metadata.total_token_count}&quot;)&#10;        &#10;        return True&#10;        &#10;    except Exception as e:&#10;        print(f&quot;❌ API 연결 실패: {e}&quot;)&#10;        &#10;        # 구체적인 오류 분석&#10;        error_str = str(e).lower()&#10;        if &quot;invalid api key&quot; in error_str or &quot;authentication&quot; in error_str:&#10;            print(&quot; API 키가 유효하지 않습니다.&quot;)&#10;            print(&quot;   - Google AI Studio에서 새로운 API 키를 발급받아보세요.&quot;)&#10;            print(&quot;   - API 키를 복사할 때 공백이나 특수문자가 포함되지 않았는지 확인하세요.&quot;)&#10;        elif &quot;quota&quot; in error_str or &quot;limit&quot; in error_str:&#10;            print(&quot; API 사용량 한도 초과입니다.&quot;)&#10;            print(&quot;   - 잠시 후 다시 시도하거나 유료 플랜을 고려해보세요.&quot;)&#10;        elif &quot;network&quot; in error_str or &quot;connection&quot; in error_str:&#10;            print(&quot; 네트워크 연결 문제입니다.&quot;)&#10;            print(&quot;   - 인터넷 연결을 확인하세요.&quot;)&#10;            print(&quot;   - VPN을 사용 중이라면 끄고 시도해보세요.&quot;)&#10;        else:&#10;            print(&quot;❓ 알 수 없는 오류입니다.&quot;)&#10;            print(f&quot;   상세 오류: {e}&quot;)&#10;        &#10;        return False&#10;&#10;def create_env_template():&#10;    &quot;&quot;&quot;환경 변수 템플릿 파일을 생성합니다.&quot;&quot;&quot;&#10;    env_content = &quot;&quot;&quot;# Google Gemini API 키&#10;# https://aistudio.google.com/app/apikey 에서 발급받으세요&#10;GOOGLE_AI_API_KEY=your_api_key_here&#10;&#10;# 사용 예시:&#10;# GOOGLE_AI_API_KEY=AIzaSyBxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&#10;&quot;&quot;&quot;&#10;    &#10;    with open('.env.template', 'w', encoding='utf-8') as f:&#10;        f.write(env_content)&#10;    &#10;    print(&quot; .env.template 파일이 생성되었습니다.&quot;)&#10;    print(&quot;   이 파일을 참고하여 .env 파일을 만들어주세요.&quot;)&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    print(&quot;=&quot; * 50)&#10;    if not diagnose_gemini_connection():&#10;        print(&quot;\n 문제 해결 가이드:&quot;)&#10;        print(&quot;1. Google AI Studio 접속: https://aistudio.google.com/app/apikey&quot;)&#10;        print(&quot;2. 'Create API key' 클릭&quot;)&#10;        print(&quot;3. API 키 복사&quot;)&#10;        print(&quot;4. .env 파일에 GOOGLE_AI_API_KEY=복사한_키 추가&quot;)&#10;        print(&quot;5. 다시 실행&quot;)&#10;        &#10;        create_env_template()&#10;    print(&quot;=&quot; * 50)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/gemini.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/gemini.py" />
              <option name="originalContent" value="import time&#10;from typing import Optional&#10;from dotenv import load_dotenv&#10;import os&#10;import re&#10;import regex&#10;import json&#10;load_dotenv()&#10;&#10;from google import genai&#10;from google.genai import types&#10;&#10;model_name = &quot;gemini-2.0-flash-001&quot;&#10;&#10;# .env 파일에서 API 키 로드 (보안 강화)&#10;client = genai.Client(api_key=os.getenv(&quot;GOOGLE_AI_API_KEY&quot;))&#10;&#10;def ask_question_to_gemini_cache(prompt, max_retries=5, retry_delay=5):&#10;    &quot;&quot;&quot;&#10;    Gemini API를 사용하여 질문에 대한 답변을 얻습니다.&#10;    뉴스 분석에 최적화된 버전입니다.&#10;    &quot;&quot;&quot;&#10;    start_time = time.time()&#10;&#10;    for attempt in range(max_retries):&#10;        try:&#10;            # API 키 확인&#10;            api_key = os.getenv(&quot;GOOGLE_AI_API_KEY&quot;)&#10;            if not api_key:&#10;                raise Exception(&quot;GOOGLE_AI_API_KEY 환경 변수가 설정되지 않았습니다.&quot;)&#10;&#10;            api_start = time.time()&#10;&#10;            # Gemini API 호출&#10;            response = client.models.generate_content(&#10;                model=model_name,&#10;                contents=prompt,&#10;                config=types.GenerateContentConfig(&#10;                    temperature=0.3,&#10;                    max_output_tokens=2048&#10;                )&#10;            )&#10;&#10;            return response.text&#10;&#10;        except Exception as e:&#10;            error_msg = str(e).lower()&#10;            print(f&quot;API 오류 (시도 {attempt + 1}/{max_retries}): {e}&quot;)&#10;&#10;            if hasattr(e, 'code') and e.code == 503:&#10;                print(f&quot;⏳ API 사용량 한도 초과 (시도 {attempt + 1}/{max_retries}). {retry_delay}초 후 재시도...&quot;)&#10;                time.sleep(retry_delay)&#10;            elif &quot;invalid api key&quot; in error_msg or &quot;authentication&quot; in error_msg:&#10;                print(&quot;❌ API 키가 유효하지 않습니다. .env 파일을 확인하세요.&quot;)&#10;                break&#10;            elif &quot;quota&quot; in error_msg or &quot;limit&quot; in error_msg:&#10;                print(f&quot;⏳ API 사용량 한도 초과. {retry_delay}초 후 재시도...&quot;)&#10;                time.sleep(retry_delay)&#10;            else:&#10;                print(f&quot; Gemini API 오류 (시도 {attempt + 1}/{max_retries}): {e}&quot;)&#10;                if attempt == max_retries - 1:&#10;                    raise&#10;&#10;    print(f&quot;{max_retries}번 시도 후 실패. 총 소요시간: {time.time() - start_time:.2f}초&quot;)&#10;    return None&#10;&#10;def create_news_analysis_prompt(combined_text: str) -&gt; str:&#10;    &quot;&quot;&quot;&#10;    뉴스 분석을 위한 통합 프롬프트 생성&#10;    &quot;&quot;&quot;&#10;    return f&quot;&quot;&quot;&#10;너는 국내 상장사와 주요 산업 분석에 특화된 금융 뉴스 분석 전문가야.&#10;&#10;{combined_text}&#10;&#10;뉴스 기사에 대해, 기계적 추출이 아닌 **생성적 요약**으로 다음 항목들을 JSON 형식으로 분석해주세요:&#10;&#10;1. overall_sentiment: 전체적인 시장 감정 (positive/negative/neutral)&#10;2. sentiment_score: 감정 점수 (-100 ~ +100, 숫자로만)&#10;3. key_themes: 주요 테마들 (배열)&#10;4. market_impact: 시장에 미칠 영향 예측 (2-3문장)&#10;5. summary: 전체 뉴스 요약 (3-4문장)&#10;6. investment_signals: 투자 시그널 (buy/sell/hold)&#10;&#10;### 출력 형식 (JSON)&#10;{{&#10;  &quot;overall_sentiment&quot;: &quot;positive/negative/neutral&quot;,&#10;  &quot;sentiment_score&quot;: 숫자,&#10;  &quot;key_themes&quot;: [&quot;테마1&quot;, &quot;테마2&quot;, &quot;테마3&quot;],&#10;  &quot;market_impact&quot;: &quot;시장 영향 분석&quot;,&#10;  &quot;summary&quot;: &quot;전체 뉴스 요약&quot;,&#10;  &quot;investment_signals&quot;: &quot;buy/sell/hold&quot;&#10;}}&#10;&#10;### 분석 가이드라인:&#10;• 답변 형식: 반드시 유효한 JSON 구조로 작성해주세요&#10;• 언어: 한국어로 자연스럽게 작성&#10;• 분석 스타일: 객관적이고 균형잡힌 관점 유지&#10;• 근거: 실제 데이터와 시장 동향에 기반한 분석&#10;• 투자 조언: 과도한 투기보다는 신중한 투자 관점 제시&#10;&#10;응답은 반드시 JSON 형식으로만 해주세요.&#10;&quot;&quot;&quot;&#10;&#10;def ask_news_analysis(prompt, max_retries=3):&#10;    &quot;&quot;&quot;&#10;    뉴스 분석 전용 Gemini API 호출 함수&#10;    JSON 응답을 기대하는 뉴스 분석에 최적화&#10;    &quot;&quot;&quot;&#10;    return ask_question_to_gemini_cache(prompt, max_retries=max_retries)&#10;&#10;def create_research_reports_analysis_prompt(combined_text: str) -&gt; str:&#10;    &quot;&quot;&quot;&#10;    리서치 리포트 분석을 위한 통합 프롬프트 생성&#10;    &quot;&quot;&quot;&#10;    return f&quot;&quot;&quot;&#10;너는 국내 증권사 리서치 분석에 특화된 금융 전문가야.&#10;&#10;다음 네이버 증권 리서치 뉴스와 리포트들을 카테고리별로 분석해주세요:&#10;&#10;{combined_text}&#10;&#10;뉴스와 리포트에 대해, 종합적이고 심층적인 분석으로 다음 항목들을 JSON 형식으로 분석해주세요:&#10;&#10;1. category_summary: 카테고리별 요약 (각 카테고리당 2-3문장씩, 객체 형태)&#10;2. top_mentioned_stocks: 가장 많이 언급된 종목들 (배열, 최대 10개)&#10;3. key_industries: 주요 관심 산업/섹터들 (배열, 최대 8개)&#10;4. investment_themes: 주요 투자 테마들 (배열, 최대 8개)&#10;5. market_outlook: 전체 시장 전망 (bullish/bearish/neutral)&#10;6. risk_factors: 주요 리스크 요인들 (배열, 각 한 문장, 최대 5개)&#10;7. opportunities: 투자 기회들 (배열, 각 한 문장, 최대 5개)&#10;8. analyst_consensus: 애널리스트들의 전반적 합의 사항 (2-3문장)&#10;9. summary: 전체 리포트 종합 분석 (4-5문장)&#10;&#10;### 출력 형식 (JSON)&#10;{{&#10;  &quot;category_summary&quot;: {{&#10;    &quot;종목분석&quot;: &quot;종목분석 카테고리 요약 2-3문장&quot;,&#10;    &quot;산업분석&quot;: &quot;산업분석 카테고리 요약 2-3문장&quot;,&#10;    &quot;시황정보&quot;: &quot;시황정보 카테고리 요약 2-3문장&quot;,&#10;    &quot;투자정보&quot;: &quot;투자정보 카테고리 요약 2-3문장&quot;&#10;  }},&#10;  &quot;top_mentioned_stocks&quot;: [&quot;종목1&quot;, &quot;종목2&quot;, &quot;종목3&quot;],&#10;  &quot;key_industries&quot;: [&quot;산업1&quot;, &quot;산업2&quot;, &quot;산업3&quot;],&#10;  &quot;investment_themes&quot;: [&quot;테마1&quot;, &quot;테마2&quot;, &quot;테마3&quot;],&#10;  &quot;market_outlook&quot;: &quot;bullish/bearish/neutral&quot;,&#10;  &quot;risk_factors&quot;: [&quot;리스크 요인 1&quot;, &quot;리스크 요인 2&quot;],&#10;  &quot;opportunities&quot;: [&quot;투자 기회 1&quot;, &quot;투자 기회 2&quot;],&#10;  &quot;analyst_consensus&quot;: &quot;애널리스트 합의 사항 2-3문장&quot;,&#10;  &quot;summary&quot;: &quot;전체 종합 분석 4-5문장&quot;&#10;}}&#10;&#10;### 분석 가이드라인:&#10;• 답변 형식: 반드시 유효한 JSON 구조로 작성해주세요&#10;• 언어: 한국어로 자연스럽게 작성&#10;• 분석 스타일: 객관적이고 전문적인 관점 유지&#10;• 근거: 실제 리포트 내용과 시장 동향에 기반한 분석&#10;• 투자 조언: 신중하고 균형잡힌 투자 관점 제시&#10;• 완성도: 모든 9개 항목을 빠짐없이 포함해야 함&#10;&#10;응답은 반드시 JSON 형식으로만 해주세요.&#10;&quot;&quot;&quot;&#10;&#10;def json_match(input_string):&#10;    &quot;&quot;&quot;&#10;    Use regex to extract JSON from a string.&#10;    &quot;&quot;&quot;&#10;    if not input_string:&#10;        return None&#10;&#10;    print(&quot;응답 텍스트에서 JSON 추출 시도...&quot;)&#10;&#10;    # 1. 백틱으로 감싸진 JSON 찾기 (개선된 regex 사용)&#10;    pattern_backticks = r'```json\s*(\{.*?\})\s*```'&#10;    m = re.search(pattern_backticks, input_string, re.DOTALL)&#10;    if m:&#10;        json_str = m.group(1)&#10;        try:&#10;            result = json.loads(json_str)&#10;            print(&quot;백틱 JSON 추출 성공&quot;)&#10;            return result&#10;        except json.JSONDecodeError as e:&#10;            print(f&quot;백틱 JSON 파싱 실패: {e}&quot;)&#10;            # 손상된 JSON 복구 시도&#10;            fixed_json = _try_fix_json(json_str)&#10;            if fixed_json:&#10;                return fixed_json&#10;&#10;    # 2. regex 라이브러리가 있다면 고급 패턴 사용&#10;    try:&#10;        pattern_simple = r'(\{(?:[^{}]|(?R))*\})'&#10;        m = regex.search(pattern_simple, input_string)&#10;        if m:&#10;            json_str = m.group(1)&#10;            try:&#10;                result = json.loads(json_str)&#10;                print(&quot;고급 regex JSON 추출 성공&quot;)&#10;                return result&#10;            except json.JSONDecodeError as e:&#10;                print(f&quot;고급 regex JSON 파싱 실패: {e}&quot;)&#10;                # 손상된 JSON 복구 시도&#10;                fixed_json = _try_fix_json(json_str)&#10;                if fixed_json:&#10;                    return fixed_json&#10;    except NameError:&#10;        # regex 라이브러리가 없는 경우 기본 패턴 사용&#10;        pass&#10;&#10;    # 3. 기본 re 모듈로 간단한 패턴 시도&#10;    try:&#10;        # 여러 JSON 객체를 찾아서 가장 완전한 것 선택&#10;        json_candidates = []&#10;&#10;        # 모든 { } 찾기&#10;        brace_count = 0&#10;        start_pos = -1&#10;&#10;        for i, char in enumerate(input_string):&#10;            if char == '{':&#10;                if brace_count == 0:&#10;                    start_pos = i&#10;                brace_count += 1&#10;            elif char == '}':&#10;                brace_count -= 1&#10;                if brace_count == 0 and start_pos != -1:&#10;                    json_candidate = input_string[start_pos:i+1]&#10;                    json_candidates.append(json_candidate)&#10;&#10;        # 가장 긴 JSON 후보를 먼저 시도&#10;        json_candidates.sort(key=len, reverse=True)&#10;&#10;        for json_str in json_candidates:&#10;            try:&#10;                result = json.loads(json_str)&#10;                print(&quot;기본 JSON 추출 성공&quot;)&#10;                return result&#10;            except json.JSONDecodeError:&#10;                # 손상된 JSON 복구 시도&#10;                fixed_json = _try_fix_json(json_str)&#10;                if fixed_json:&#10;                    return fixed_json&#10;                continue&#10;&#10;    except Exception as e:&#10;        print(f&quot;기본 JSON 파싱 중 오류: {e}&quot;)&#10;&#10;    print(&quot;JSON 추출 실패&quot;)&#10;    return None&#10;&#10;def _try_fix_json(json_str: str) -&gt; Optional[dict]:&#10;    &quot;&quot;&quot;&#10;    손상된 JSON을 복구하려고 시도&#10;    &quot;&quot;&quot;&#10;    print(&quot;손상된 JSON 복구 시도...&quot;)&#10;&#10;    try:&#10;        # 1. 흔한 문제들 수정&#10;        fixed_str = json_str&#10;&#10;        # 잘못된 키 이름 패턴 수정 (예: &quot;텍스트key&quot;: -&gt; &quot;key&quot;:)&#10;        import re&#10;        fixed_str = re.sub(r'&quot;[^&quot;]*[가-힣][^&quot;]*([a-zA-Z_][a-zA-Z0-9_]*)&quot;:', r'&quot;\1&quot;:', fixed_str)&#10;&#10;        # 중간에 끊어진 문자열 + 키 패턴 수정&#10;        fixed_str = re.sub(r'&quot;[^&quot;]*&quot;([a-zA-Z_][a-zA-Z0-9_]*)&quot;:', r'&quot;, &quot;\1&quot;:', fixed_str)&#10;&#10;        # 잘 구분된 쉼표 패턴 수정&#10;        fixed_str = re.sub(r',\s*}', '}', fixed_str)&#10;        fixed_str = re.sub(r',\s*]', ']', fixed_str)&#10;&#10;        # 2. JSON 파싱 재시도&#10;        result = json.loads(fixed_str)&#10;        print(&quot;JSON 복구 성공!&quot;)&#10;        return result&#10;&#10;    except json.JSONDecodeError as e:&#10;        print(f&quot;JSON 복구 실패: {e}&quot;)&#10;&#10;        # 3. 부분 복구 시도 - 유효한 필드만 추출&#10;        try:&#10;            partial_data = {}&#10;&#10;            # 간단한 키-값 쌍 추출&#10;            simple_patterns = [&#10;                (r'&quot;([^&quot;]+)&quot;:\s*&quot;([^&quot;]*)&quot;', str),  # 문자열 값&#10;                (r'&quot;([^&quot;]+)&quot;:\s*(\d+(?:\.\d+)?)', float),  # 숫자 값&#10;                (r'&quot;([^&quot;]+)&quot;:\s*(true|false)', bool),  # 불린 값&#10;            ]&#10;&#10;            for pattern, value_type in simple_patterns:&#10;                matches = re.findall(pattern, json_str)&#10;                for key, value in matches:&#10;                    try:&#10;                        if value_type == bool:&#10;                            partial_data[key] = value.lower() == 'true'&#10;                        elif value_type == float:&#10;                            partial_data[key] = float(value)&#10;                        else:&#10;                            partial_data[key] = value&#10;                    except:&#10;                        continue&#10;&#10;            if partial_data:&#10;                print(f&quot;부분 JSON 복구 성공: {len(partial_data)}개 필드&quot;)&#10;                return partial_data&#10;&#10;        except Exception as e:&#10;            print(f&quot;부분 복구도 실패: {e}&quot;)&#10;&#10;    return None" />
              <option name="updatedContent" value="import time&#10;from typing import Optional&#10;from dotenv import load_dotenv&#10;import os&#10;import re&#10;import regex&#10;import json&#10;load_dotenv()&#10;&#10;from google import genai&#10;from google.genai import types&#10;&#10;model_name = &quot;gemini-2.0-flash-001&quot;&#10;&#10;# .env 파일에서 API 키 로드 (보안 강화)&#10;client = genai.Client(api_key=os.getenv(&quot;GOOGLE_AI_API_KEY&quot;))&#10;&#10;def ask_question_to_gemini_cache(prompt, max_retries=5, retry_delay=5):&#10;    &quot;&quot;&quot;&#10;    Gemini API를 사용하여 질문에 대한 답변을 얻습니다.&#10;    뉴스 분석에 최적화된 버전입니다.&#10;    &quot;&quot;&quot;&#10;    start_time = time.time()&#10;&#10;    for attempt in range(max_retries):&#10;        try:&#10;            # API 키 확인&#10;            api_key = os.getenv(&quot;GOOGLE_AI_API_KEY&quot;)&#10;            if not api_key:&#10;                raise Exception(&quot;GOOGLE_AI_API_KEY 환경 변수가 설정되지 않았습니다.&quot;)&#10;&#10;            api_start = time.time()&#10;&#10;            # Gemini API 호출&#10;            response = client.models.generate_content(&#10;                model=model_name,&#10;                contents=prompt,&#10;                config=types.GenerateContentConfig(&#10;                    temperature=0.3,&#10;                    max_output_tokens=2048&#10;                )&#10;            )&#10;&#10;            return response.text&#10;&#10;        except Exception as e:&#10;            error_msg = str(e).lower()&#10;            print(f&quot;API 오류 (시도 {attempt + 1}/{max_retries}): {e}&quot;)&#10;&#10;            if hasattr(e, 'code') and e.code == 503:&#10;                print(f&quot;⏳ API 사용량 한도 초과 (시도 {attempt + 1}/{max_retries}). {retry_delay}초 후 재시도...&quot;)&#10;                time.sleep(retry_delay)&#10;            elif &quot;invalid api key&quot; in error_msg or &quot;authentication&quot; in error_msg:&#10;                print(&quot;❌ API 키가 유효하지 않습니다. .env 파일을 확인하세요.&quot;)&#10;                break&#10;            elif &quot;quota&quot; in error_msg or &quot;limit&quot; in error_msg:&#10;                print(f&quot;⏳ API 사용량 한도 초과. {retry_delay}초 후 재시도...&quot;)&#10;                time.sleep(retry_delay)&#10;            else:&#10;                print(f&quot; Gemini API 오류 (시도 {attempt + 1}/{max_retries}): {e}&quot;)&#10;                if attempt == max_retries - 1:&#10;                    raise&#10;&#10;    print(f&quot;{max_retries}번 시도 후 실패. 총 소요시간: {time.time() - start_time:.2f}초&quot;)&#10;    return None&#10;&#10;def create_news_analysis_prompt(combined_text: str) -&gt; str:&#10;    &quot;&quot;&quot;&#10;    뉴스 분석을 위한 통합 프롬프트 생성&#10;    &quot;&quot;&quot;&#10;    return f&quot;&quot;&quot;&#10;너는 국내 상장사와 주요 산업 분석에 특화된 금융 뉴스 분석 전문가야.&#10;&#10;{combined_text}&#10;&#10;뉴스 기사에 대해, 기계적 추출이 아닌 **생성적 요약**으로 다음 항목들을 JSON 형식으로 분석해주세요:&#10;&#10;1. overall_sentiment: 전체적인 시장 감정 (positive/negative/neutral)&#10;2. sentiment_score: 감정 점수 (-100 ~ +100, 숫자로만)&#10;3. key_themes: 주요 테마들 (배열)&#10;4. market_impact: 시장에 미칠 영향 예측 (2-3문장)&#10;5. summary: 전체 뉴스 요약 (3-4문장)&#10;6. investment_signals: 투자 시그널 (buy/sell/hold)&#10;&#10;### 출력 형식 (JSON)&#10;{{&#10;  &quot;overall_sentiment&quot;: &quot;positive/negative/neutral&quot;,&#10;  &quot;sentiment_score&quot;: 숫자,&#10;  &quot;key_themes&quot;: [&quot;테마1&quot;, &quot;테마2&quot;, &quot;테마3&quot;],&#10;  &quot;market_impact&quot;: &quot;시장 영향 분석&quot;,&#10;  &quot;summary&quot;: &quot;전체 뉴스 요약&quot;,&#10;  &quot;investment_signals&quot;: &quot;buy/sell/hold&quot;&#10;}}&#10;&#10;### 분석 가이드라인:&#10;• 답변 형식: 반드시 유효한 JSON 구조로 작성해주세요&#10;• 언어: 한국어로 자연스럽게 작성&#10;• 분석 스타일: 객관적이고 균형잡힌 관점 유지&#10;• 근거: 실제 데이터와 시장 동향에 기반한 분석&#10;• 투자 조언: 과도한 투기보다는 신중한 투자 관점 제시&#10;&#10;응답은 반드시 JSON 형식으로만 해주세요.&#10;&quot;&quot;&quot;&#10;&#10;def ask_news_analysis(prompt, max_retries=3):&#10;    &quot;&quot;&quot;&#10;    뉴스 분석 전용 Gemini API 호출 함수&#10;    JSON 응답을 기대하는 뉴스 분석에 최적화&#10;    &quot;&quot;&quot;&#10;    return ask_question_to_gemini_cache(prompt, max_retries=max_retries)&#10;&#10;def create_research_reports_analysis_prompt(combined_text: str) -&gt; str:&#10;    &quot;&quot;&quot;&#10;    리서치 리포트 분석을 위한 통합 프롬프트 생성&#10;    &quot;&quot;&quot;&#10;    return f&quot;&quot;&quot;&#10;너는 국내 증권사 리서치 분석에 특화된 금융 전문가야.&#10;&#10;다음 네이버 증권 리서치 뉴스와 리포트들을 카테고리별로 분석해주세요:&#10;&#10;{combined_text}&#10;&#10;뉴스와 리포트에 대해, 종합적이고 심층적인 분석으로 다음 항목들을 JSON 형식으로 분석해주세요:&#10;&#10;1. category_summary: 카테고리별 요약 (각 카테고리당 2-3문장씩, 객체 형태)&#10;2. top_mentioned_stocks: 가장 많이 언급된 종목들 (배열, 최대 10개)&#10;3. key_industries: 주요 관심 산업/섹터들 (배열, 최대 8개)&#10;4. investment_themes: 주요 투자 테마들 (배열, 최대 8개)&#10;5. market_outlook: 전체 시장 전망 (bullish/bearish/neutral)&#10;6. risk_factors: 주요 리스크 요인들 (배열, 각 한 문장, 최대 5개)&#10;7. opportunities: 투자 기회들 (배열, 각 한 문장, 최대 5개)&#10;8. analyst_consensus: 애널리스트들의 전반적 합의 사항 (2-3문장)&#10;9. summary: 전체 리포트 종합 분석 (4-5문장)&#10;&#10;### 출력 형식 (JSON)&#10;{{&#10;  &quot;category_summary&quot;: {{&#10;    &quot;종목분석&quot;: &quot;종목분석 카테고리 요약 2-3문장&quot;,&#10;    &quot;산업분석&quot;: &quot;산업분석 카테고리 요약 2-3문장&quot;,&#10;    &quot;시황정보&quot;: &quot;시황정보 카테고리 요약 2-3문장&quot;,&#10;    &quot;투자정보&quot;: &quot;투자정보 카테고리 요약 2-3문장&quot;&#10;  }},&#10;  &quot;top_mentioned_stocks&quot;: [&quot;종목1&quot;, &quot;종목2&quot;, &quot;종목3&quot;],&#10;  &quot;key_industries&quot;: [&quot;산업1&quot;, &quot;산업2&quot;, &quot;산업3&quot;],&#10;  &quot;investment_themes&quot;: [&quot;테마1&quot;, &quot;테마2&quot;, &quot;테마3&quot;],&#10;  &quot;market_outlook&quot;: &quot;bullish/bearish/neutral&quot;,&#10;  &quot;risk_factors&quot;: [&quot;리스크 요인 1&quot;, &quot;리스크 요인 2&quot;],&#10;  &quot;opportunities&quot;: [&quot;투자 기회 1&quot;, &quot;투자 기회 2&quot;],&#10;  &quot;analyst_consensus&quot;: &quot;애널리스트 합의 사항 2-3문장&quot;,&#10;  &quot;summary&quot;: &quot;전체 종합 분석 4-5문장&quot;&#10;}}&#10;&#10;### 분석 가이드라인:&#10;• 답변 형식: 반드시 유효한 JSON 구조로 작성해주세요&#10;• 언어: 한국어로 자연스럽게 작성&#10;• 분석 스타일: 객관적이고 전문적인 관점 유지&#10;• 근거: 실제 리포트 내용과 시장 동향에 기반한 분석&#10;• 투자 조언: 신중하고 균형잡힌 투자 관점 제시&#10;• 완성도: 모든 9개 항목을 빠짐없이 포함해야 함&#10;&#10;응답은 반드시 JSON 형식으로만 해주세요.&#10;&quot;&quot;&quot;&#10;&#10;def create_individual_news_analysis_prompt(news_item: dict) -&gt; str:&#10;    &quot;&quot;&quot;&#10;    개별 뉴스 분석을 위한 프롬프트 생성&#10;    &quot;&quot;&quot;&#10;    title = news_item.get('title', '')&#10;    content = news_item.get('content', '')&#10;    &#10;    # 내용이 없으면 제목만 사용&#10;    text_to_analyze = content if content.strip() else title&#10;    &#10;    return f&quot;&quot;&quot;&#10;너는 국내 상장사와 주요 산업 분석에 특화된 금융 뉴스 분석 전문가야.&#10;&#10;다음 뉴스 기사를 분석해주세요:&#10;&#10;제목: {title}&#10;내용: {text_to_analyze[:500]}&#10;&#10;뉴스 기사에 대해, 기계적 추출이 아닌 **생성적 요약**으로 다음 항목들을 JSON 형식으로 분석해주세요:&#10;&#10;1. summary: 주요 이슈 한 문장 요약&#10;2. entities: 관련 기업명과/또는 업종명 명시&#10;3. impact: 업계·시장 파급 영��� 또는 의미 부각&#10;4. type: 기업 또는 산업 (정확히 이 두 단어 중 하나만)&#10;5. reason: 이 기사 분류의 근거 (기업/산업)&#10;&#10;### 분류 지침:&#10;- 특정 기업(예: 삼성전자, 현대차 등)에 대한 기사면 &quot;type&quot;: &quot;기업&quot;으로,&#10;- 정부 정책, 산업 정책, 경제 지표(금리, 환율 등), 법/제도, 또는 특정 산업 전체에 대한 기사면 &quot;type&quot;: &quot;산업&quot;으로 분류.&#10;- 분류 사유는 기사 내용 근거를 1문장으로 명확히 설명할 것.&#10;&#10;### 출력 형식 (JSON)&#10;{{&#10;  &quot;summary&quot;: &quot;&lt;주요 이슈 한 문장 요약&gt;&quot;,&#10;  &quot;entities&quot;: &quot;&lt;관련 기업명과/또는 업종명 명시&gt;&quot;,&#10;  &quot;impact&quot;: &quot;&lt;업계·시장 파급 영향 또는 의미 부각&gt;&quot;,&#10;  &quot;type&quot;: &quot;기업 또는 산업&quot;,&#10;  &quot;reason&quot;: &quot;&lt;이 기사 분류의 근거 (기업/산업)&gt;&quot;&#10;}}&#10;&#10;### 분석 가이드라인:&#10;• 답변 형식: 반드시 유효한 JSON 구조로 작성해주세요&#10;• 언어: 한국어로 자연스럽게 작��&#10;• 분석 스타일: 객관적이고 균형잡힌 관점 유지&#10;• 근거: 실제 데이터와 시장 동향에 기반한 분석&#10;• 투자 조언: 과도한 투기보다는 신중한 투자 관점 제시&#10;&#10;응답은 반드시 JSON 형식으로만 해주세요.&#10;&quot;&quot;&quot;&#10;&#10;def json_match(input_string):&#10;    &quot;&quot;&quot;&#10;    Use regex to extract JSON from a string.&#10;    &quot;&quot;&quot;&#10;    if not input_string:&#10;        return None&#10;&#10;    print(&quot;응답 텍스트에서 JSON 추출 시도...&quot;)&#10;&#10;    # 1. 백틱으로 감싸진 JSON 찾기 (개선된 regex 사용)&#10;    pattern_backticks = r'```json\s*(\{.*?\})\s*```'&#10;    m = re.search(pattern_backticks, input_string, re.DOTALL)&#10;    if m:&#10;        json_str = m.group(1)&#10;        try:&#10;            result = json.loads(json_str)&#10;            print(&quot;백틱 JSON 추출 성공&quot;)&#10;            return result&#10;        except json.JSONDecodeError as e:&#10;            print(f&quot;백틱 JSON 파싱 실패: {e}&quot;)&#10;            # 손상된 JSON 복구 시도&#10;            fixed_json = _try_fix_json(json_str)&#10;            if fixed_json:&#10;                return fixed_json&#10;&#10;    # 2. regex 라이브러리가 있다면 고급 패턴 사용&#10;    try:&#10;        pattern_simple = r'(\{(?:[^{}]|(?R))*\})'&#10;        m = regex.search(pattern_simple, input_string)&#10;        if m:&#10;            json_str = m.group(1)&#10;            try:&#10;                result = json.loads(json_str)&#10;                print(&quot;고급 regex JSON 추출 성공&quot;)&#10;                return result&#10;            except json.JSONDecodeError as e:&#10;                print(f&quot;고급 regex JSON 파싱 실패: {e}&quot;)&#10;                # 손상된 JSON 복구 시도&#10;                fixed_json = _try_fix_json(json_str)&#10;                if fixed_json:&#10;                    return fixed_json&#10;    except NameError:&#10;        # regex 라이브러리가 없는 경우 기본 패턴 사용&#10;        pass&#10;&#10;    # 3. 기본 re 모듈로 간단한 패턴 시도&#10;    try:&#10;        # 여러 JSON 객체를 찾아서 가장 완전한 것 선택&#10;        json_candidates = []&#10;&#10;        # 모든 { } 찾기&#10;        brace_count = 0&#10;        start_pos = -1&#10;&#10;        for i, char in enumerate(input_string):&#10;            if char == '{':&#10;                if brace_count == 0:&#10;                    start_pos = i&#10;                brace_count += 1&#10;            elif char == '}':&#10;                brace_count -= 1&#10;                if brace_count == 0 and start_pos != -1:&#10;                    json_candidate = input_string[start_pos:i+1]&#10;                    json_candidates.append(json_candidate)&#10;&#10;        # 가장 긴 JSON 후보를 먼저 시도&#10;        json_candidates.sort(key=len, reverse=True)&#10;&#10;        for json_str in json_candidates:&#10;            try:&#10;                result = json.loads(json_str)&#10;                print(&quot;기본 JSON 추출 성공&quot;)&#10;                return result&#10;            except json.JSONDecodeError:&#10;                # 손상된 JSON 복구 시도&#10;                fixed_json = _try_fix_json(json_str)&#10;                if fixed_json:&#10;                    return fixed_json&#10;                continue&#10;&#10;    except Exception as e:&#10;        print(f&quot;기본 JSON 파싱 중 오류: {e}&quot;)&#10;&#10;    print(&quot;JSON 추출 실패&quot;)&#10;    return None&#10;&#10;def _try_fix_json(json_str: str) -&gt; Optional[dict]:&#10;    &quot;&quot;&quot;&#10;    손상된 JSON을 복구하려고 시도&#10;    &quot;&quot;&quot;&#10;    print(&quot;손상된 JSON 복구 시도...&quot;)&#10;&#10;    try:&#10;        # 1. 흔한 문제들 수정&#10;        fixed_str = json_str&#10;&#10;        # 잘못된 키 이름 패턴 수정 (예: &quot;텍스트key&quot;: -&gt; &quot;key&quot;:)&#10;        import re&#10;        fixed_str = re.sub(r'&quot;[^&quot;]*[가-힣][^&quot;]*([a-zA-Z_][a-zA-Z0-9_]*)&quot;:', r'&quot;\1&quot;:', fixed_str)&#10;&#10;        # 중간에 끊어진 문자열 + 키 패턴 수정&#10;        fixed_str = re.sub(r'&quot;[^&quot;]*&quot;([a-zA-Z_][a-zA-Z0-9_]*)&quot;:', r'&quot;, &quot;\1&quot;:', fixed_str)&#10;&#10;        # 잘 구분된 쉼표 패턴 수정&#10;        fixed_str = re.sub(r',\s*}', '}', fixed_str)&#10;        fixed_str = re.sub(r',\s*]', ']', fixed_str)&#10;&#10;        # 2. JSON 파싱 재시도&#10;        result = json.loads(fixed_str)&#10;        print(&quot;JSON 복구 성공!&quot;)&#10;        return result&#10;&#10;    except json.JSONDecodeError as e:&#10;        print(f&quot;JSON 복구 실패: {e}&quot;)&#10;&#10;        # 3. 부분 복구 시도 - 유효한 필드만 추출&#10;        try:&#10;            partial_data = {}&#10;&#10;            # 간단한 키-값 쌍 추출&#10;            simple_patterns = [&#10;                (r'&quot;([^&quot;]+)&quot;:\s*&quot;([^&quot;]*)&quot;', str),  # 문자열 값&#10;                (r'&quot;([^&quot;]+)&quot;:\s*(\d+(?:\.\d+)?)', float),  # 숫자 값&#10;                (r'&quot;([^&quot;]+)&quot;:\s*(true|false)', bool),  # 불린 값&#10;            ]&#10;&#10;            for pattern, value_type in simple_patterns:&#10;                matches = re.findall(pattern, json_str)&#10;                for key, value in matches:&#10;                    try:&#10;                        if value_type == bool:&#10;                            partial_data[key] = value.lower() == 'true'&#10;                        elif value_type == float:&#10;                            partial_data[key] = float(value)&#10;                        else:&#10;                            partial_data[key] = value&#10;                    except:&#10;                        continue&#10;&#10;            if partial_data:&#10;                print(f&quot;부분 JSON 복구 성공: {len(partial_data)}개 필드&quot;)&#10;                return partial_data&#10;&#10;        except Exception as e:&#10;            print(f&quot;부분 복구도 실패: {e}&quot;)&#10;&#10;    return None" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/llm_core/news_trading_system.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/llm_core/news_trading_system.py" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/llm_news/requirements.txt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/llm_news/requirements.txt" />
              <option name="updatedContent" value="requests==2.31.0&#10;beautifulsoup4==4.12.2&#10;python-dotenv==1.0.0&#10;google-generativeai==0.3.2" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/llm_news/test_headline_crawler.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/llm_news/test_headline_crawler.py" />
              <option name="originalContent" value="#!/usr/bin/env python3&#10;&quot;&quot;&quot;&#10;네이버 뉴스 헤드라인 크롤러 테스트 스크립트&#10;정치 섹션(101)에서 헤드라인 뉴스 20개를 크롤링하고 JSON으로 저장&#10;&quot;&quot;&quot;&#10;&#10;import sys&#10;import os&#10;import json&#10;from datetime import datetime&#10;&#10;# 현재 디렉토리를 Python 경로에 추가&#10;sys.path.append(os.path.dirname(os.path.abspath(__file__)))&#10;&#10;from news_crawler import NaverNewsHeadlineCrawler&#10;&#10;def main():&#10;    &quot;&quot;&quot;메인 실행 함수&quot;&quot;&quot;&#10;    print(&quot;=&quot; * 60)&#10;    print(&quot;네이버 뉴스 헤드라인 크롤러 테스트&quot;)&#10;    print(&quot;=&quot; * 60)&#10;&#10;    # 크롤러 인스턴스 생성&#10;    crawler = NaverNewsHeadlineCrawler()&#10;&#10;    # 정치 섹션(101)에서 헤드라인 뉴스 20개 크롤링&#10;    print(&quot; 네이버 뉴스 정치 섹션에서 헤드라인 뉴스 20개 크롤링 시작...&quot;)&#10;    print(&quot; URL: https://news.naver.com/section/101&quot;)&#10;    print()&#10;&#10;    try:&#10;        # 뉴스 크롤링 실행&#10;        news_list = crawler.get_headline_news(section_id=&quot;101&quot;, limit=20)&#10;&#10;        if news_list:&#10;            print(f&quot;✅ 크롤링 완료! 총 {len(news_list)}개의 뉴스를 수집했습니다.&quot;)&#10;            print()&#10;&#10;            # 결과 미리보기&#10;            print(&quot; 수집된 뉴스 미리보기:&quot;)&#10;            print(&quot;-&quot; * 60)&#10;            for i, news in enumerate(news_list[:3], 1):  # 처음 3개만 미리보기&#10;                print(f&quot;{i}. {news['title']}&quot;)&#10;                print(f&quot;    발행일: {news['publish_date']}&quot;)&#10;                print(f&quot;    언론사: {news['media']}&quot;)&#10;                print(f&quot;    본문 길이: {len(news['content'])}자&quot;)&#10;                if news['content']:&#10;                    preview = news['content'][:100] + &quot;...&quot; if len(news['content']) &gt; 100 else news['content']&#10;                    print(f&quot;    본문 미리보기: {preview}&quot;)&#10;                print()&#10;&#10;            if len(news_list) &gt; 3:&#10;                print(f&quot;... 및 {len(news_list) - 3}개 더&quot;)&#10;                print()&#10;&#10;            # JSON 파일로 저장&#10;            print(&quot; JSON 파일로 저장 중...&quot;)&#10;            filename = crawler.save_to_json(news_list)&#10;&#10;            if filename:&#10;                print(f&quot;✅ JSON 파일 저장 완료: {filename}&quot;)&#10;&#10;                # 저장된 파일 정보 출력&#10;                file_size = os.path.getsize(filename) / 1024  # KB 단위&#10;                print(f&quot; 파일 크기: {file_size:.1f} KB&quot;)&#10;&#10;                # JSON 구조 미리보기&#10;                print()&#10;                print(&quot; JSON 구조 미리보기:&quot;)&#10;                print(&quot;-&quot; * 40)&#10;&#10;                with open(filename, 'r', encoding='utf-8') as f:&#10;                    data = json.load(f)&#10;&#10;                print(f&quot; 메타데이터:&quot;)&#10;                print(f&quot;   - 총 뉴스 개수: {data['metadata']['total_count']}&quot;)&#10;                print(f&quot;   - 크롤링 시간: {data['metadata']['crawled_at']}&quot;)&#10;                print(f&quot;   - 데이터 소스: {data['metadata']['source']}&quot;)&#10;                print()&#10;&#10;                print(f&quot; 첫 번째 뉴스 구조:&quot;)&#10;                if data['news']:&#10;                    first_news = data['news'][0]&#10;                    for key, value in first_news.items():&#10;                        if key == 'content' and isinstance(value, str) and len(value) &gt; 50:&#10;                            print(f&quot;   - {key}: {value[:50]}... ({len(value)}자)&quot;)&#10;                        else:&#10;                            print(f&quot;   - {key}: {value}&quot;)&#10;            else:&#10;                print(&quot;❌ JSON 파일 저장 실패&quot;)&#10;&#10;        else:&#10;            print(&quot;❌ 뉴스 크롤링에 실패했습니다.&quot;)&#10;            print(&quot;네트워크 연결이나 웹사이트 구조 변경을 확인해주세요.&quot;)&#10;&#10;    except Exception as e:&#10;        print(f&quot;❌ 크롤링 중 오류 발생: {e}&quot;)&#10;        import traceback&#10;        print(&quot;상세 오류 정보:&quot;)&#10;        traceback.print_exc()&#10;&#10;    print()&#10;    print(&quot;=&quot; * 60)&#10;    print(&quot;테스트 완료&quot;)&#10;    print(&quot;=&quot; * 60)&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()&#10;" />
              <option name="updatedContent" value="#!/usr/bin/env python3&#10;&quot;&quot;&quot;&#10;네이버 뉴스 헤드라인 크롤러 테스트 스크립트 - 개선된 버전&#10;정치 섹션(101)에서 헤드라인 뉴스 20개를 크롤링하고 JSON으로 저장&#10;&quot;&quot;&quot;&#10;&#10;import sys&#10;import os&#10;import json&#10;from datetime import datetime&#10;&#10;# 현재 디렉토리를 Python 경로에 추가&#10;sys.path.append(os.path.dirname(os.path.abspath(__file__)))&#10;&#10;from news_crawler import NaverNewsHeadlineCrawler&#10;&#10;def test_single_article():&#10;    &quot;&quot;&quot;단일 기사 크롤링 테스트&quot;&quot;&quot;&#10;    print(&quot;=&quot; * 60)&#10;    print(&quot;단일 기사 크롤링 테스트 (art_crawl 함수)&quot;)&#10;    print(&quot;=&quot; * 60)&#10;    &#10;    # 크롤러 인스턴스 생성&#10;    crawler = NaverNewsHeadlineCrawler()&#10;    &#10;    # 테스트용 네이버 뉴스 URL (임시로 정치 섹션에서 하나 가져와서 테스트)&#10;    test_url = &quot;https://news.naver.com/section/100&quot;  # 정치 섹션&#10;    &#10;    try:&#10;        # 먼저 헤드라인에서 첫 번째 기사 URL 가져오기&#10;        print(&quot; 정치 섹션에서 테스트용 기사 URL 가져오는 중...&quot;)&#10;        &#10;        response = crawler.session.get(test_url)&#10;        response.raise_for_status()&#10;        &#10;        from bs4 import BeautifulSoup&#10;        soup = BeautifulSoup(response.content, 'html.parser')&#10;        &#10;        # 첫 번째 기사 링크 찾기&#10;        article_links = soup.select('a[href*=&quot;/article/&quot;]')&#10;        &#10;        if article_links:&#10;            first_article_url = article_links[0].get('href')&#10;            if not first_article_url.startswith('http'):&#10;                first_article_url = f&quot;https://news.naver.com{first_article_url}&quot;&#10;            &#10;            print(f&quot; 테스트 기사 URL: {first_article_url}&quot;)&#10;            print()&#10;            &#10;            # art_crawl 함수로 크롤링&#10;            print(&quot; art_crawl 함수로 크롤링 시작...&quot;)&#10;            result = crawler.art_crawl(first_article_url)&#10;            &#10;            print(&quot;✅ 크롤링 완료!&quot;)&#10;            print()&#10;            print(&quot; 크롤링 결과:&quot;)&#10;            print(&quot;-&quot; * 40)&#10;            print(f&quot;제목: {result['title']}&quot;)&#10;            print(f&quot;날짜: {result['date']}&quot;)&#10;            print(f&quot;본문 길이: {len(result['main'])}자&quot;)&#10;            &#10;            if result['main']:&#10;                preview = result['main'][:200] + &quot;...&quot; if len(result['main']) &gt; 200 else result['main']&#10;                print(f&quot;본문 미리보기: {preview}&quot;)&#10;            else:&#10;                print(&quot;⚠️ 본문을 가져오지 못했습니다.&quot;)&#10;            &#10;            print()&#10;            print(&quot; 전체 결과 JSON:&quot;)&#10;            print(json.dumps(result, ensure_ascii=False, indent=2))&#10;            &#10;        else:&#10;            print(&quot;❌ 테스트용 기사를 찾을 수 없습니다.&quot;)&#10;    &#10;    except Exception as e:&#10;        print(f&quot;❌ 테스트 중 오류 발생: {e}&quot;)&#10;&#10;def main():&#10;    &quot;&quot;&quot;메인 실행 함수&quot;&quot;&quot;&#10;    print(&quot;=&quot; * 60)&#10;    print(&quot;네이버 뉴스 헤드라인 크롤러 테스트 - 개선된 버전&quot;)&#10;    print(&quot;=&quot; * 60)&#10;    &#10;    # 먼저 단일 기사 테스트&#10;    test_single_article()&#10;    &#10;    print(&quot;\n&quot; + &quot;=&quot; * 60)&#10;    print(&quot;헤드라인 뉴스 20개 크롤링 테스트&quot;)&#10;    print(&quot;=&quot; * 60)&#10;    &#10;    # 크롤러 인스턴스 생성&#10;    crawler = NaverNewsHeadlineCrawler()&#10;    &#10;    # 정치 섹션(101)에서 헤드라인 뉴스 20개 크롤링&#10;    print(&quot; 네이버 뉴스 정치 섹션에서 헤드라인 뉴스 20개 크롤링 시작...&quot;)&#10;    print(&quot; URL: https://news.naver.com/section/101&quot;)&#10;    print()&#10;    &#10;    try:&#10;        # 뉴스 크롤링 실행&#10;        news_list = crawler.get_headline_news(section_id=&quot;101&quot;, limit=20)&#10;        &#10;        if news_list:&#10;            print(f&quot;✅ 크롤링 완료! 총 {len(news_list)}개의 뉴스를 수집했습니다.&quot;)&#10;            print()&#10;            &#10;            # 본문이 제대로 크롤링된 뉴스 개수 확인&#10;            content_success_count = sum(1 for news in news_list if news.get('content') and len(news['content']) &gt; 50)&#10;            print(f&quot; 본문 크롤링 성공률: {content_success_count}/{len(news_list)} ({content_success_count/len(news_list)*100:.1f}%)&quot;)&#10;            print()&#10;            &#10;            # 결과 미리보기&#10;            print(&quot; 수집된 뉴스 미리보기:&quot;)&#10;            print(&quot;-&quot; * 60)&#10;            for i, news in enumerate(news_list[:5], 1):  # 처음 5개만 미리보기&#10;                print(f&quot;{i}. {news['title']}&quot;)&#10;                print(f&quot;    발행일: {news['publish_date']}&quot;)&#10;                print(f&quot;    언론사: {news['media']}&quot;)&#10;                print(f&quot;    본문 길이: {len(news['content'])}자&quot;)&#10;                if news['content']:&#10;                    preview = news['content'][:150] + &quot;...&quot; if len(news['content']) &gt; 150 else news['content']&#10;                    print(f&quot;    본문 미리보기: {preview}&quot;)&#10;                else:&#10;                    print(&quot;   ⚠️ 본문을 가져오지 못했습니다.&quot;)&#10;                print()&#10;            &#10;            if len(news_list) &gt; 5:&#10;                print(f&quot;... 및 {len(news_list) - 5}개 더&quot;)&#10;                print()&#10;            &#10;            # JSON 파일로 저장&#10;            print(&quot; JSON 파일로 저장 중...&quot;)&#10;            filename = crawler.save_to_json(news_list)&#10;            &#10;            if filename:&#10;                print(f&quot;✅ JSON 파일 저장 완료: {filename}&quot;)&#10;                &#10;                # 저장된 파일 정보 출력&#10;                file_size = os.path.getsize(filename) / 1024  # KB 단위&#10;                print(f&quot; 파일 크기: {file_size:.1f} KB&quot;)&#10;                &#10;                # 성공적으로 크롤링된 뉴스들의 통계&#10;                print()&#10;                print(&quot; 크롤링 통계:&quot;)&#10;                print(&quot;-&quot; * 40)&#10;                &#10;                total_content_length = sum(len(news.get('content', '')) for news in news_list)&#10;                avg_content_length = total_content_length / len(news_list) if news_list else 0&#10;                &#10;                print(f&quot;   - 전체 뉴스 수: {len(news_list)}개&quot;)&#10;                print(f&quot;   - 본문 크롤링 성공: {content_success_count}개&quot;)&#10;                print(f&quot;   - 평균 본문 길이: {avg_content_length:.0f}자&quot;)&#10;                print(f&quot;   - 총 본문 길이: {total_content_length:,}자&quot;)&#10;                &#10;                # 언론사별 분포&#10;                media_count = {}&#10;                for news in news_list:&#10;                    media = news.get('media', '알 수 없음')&#10;                    if media:&#10;                        media_count[media] = media_count.get(media, 0) + 1&#10;                &#10;                if media_count:&#10;                    print(f&quot;   - 언론사별 분포:&quot;)&#10;                    for media, count in sorted(media_count.items(), key=lambda x: x[1], reverse=True)[:5]:&#10;                        print(f&quot;     • {media}: {count}개&quot;)&#10;            else:&#10;                print(&quot;❌ JSON 파일 저장 실패&quot;)&#10;        &#10;        else:&#10;            print(&quot;❌ 뉴스 크롤링에 실패했습니다.&quot;)&#10;            print(&quot;네트워크 연결이나 웹사이트 구조 변경을 확인해주세요.&quot;)&#10;    &#10;    except Exception as e:&#10;        print(f&quot;❌ 크롤링 중 오류 발생: {e}&quot;)&#10;        import traceback&#10;        print(&quot;상세 오류 정보:&quot;)&#10;        traceback.print_exc()&#10;    &#10;    print()&#10;    print(&quot;=&quot; * 60)&#10;    print(&quot;테스트 완료&quot;)&#10;    print(&quot;=&quot; * 60)&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/main.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/main.py" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;네이버 증권 뉴스 크롤링 및 AI 분석 시스템 메인 실행 파일&#10;&quot;&quot;&quot;&#10;&#10;import json&#10;import logging&#10;from datetime import datetime&#10;from news_crawler import NaverStockNewsCrawler&#10;from news_analyzer import NewsAnalyzer&#10;&#10;# 로깅 설정 (간단한 진행 상황 표시)&#10;logging.basicConfig(&#10;    level=logging.INFO,&#10;    format='%(message)s',&#10;    handlers=[&#10;        logging.StreamHandler()&#10;    ]&#10;)&#10;&#10;logger = logging.getLogger(__name__)&#10;&#10;class StockNewsAnalysisSystem:&#10;    &quot;&quot;&quot;주식 뉴스 분석 시스템 메인 클래스&quot;&quot;&quot;&#10;&#10;    def __init__(self):&#10;        self.crawler = NaverStockNewsCrawler()&#10;        self.analyzer = NewsAnalyzer()&#10;&#10;    def run_daily_analysis(self, news_limit: int = 10, reports_limit: int = 10) -&gt; dict:&#10;        &quot;&quot;&quot;&#10;        일일 뉴스 분석 실행 (카테고리별 상세 분석 포함)&#10;&#10;        Args:&#10;            news_limit: 크롤링할 뉴스 개수&#10;            reports_limit: 각 카테고리별로 크롤링할 리포트 개수&#10;&#10;        Returns:&#10;            Dict: 전체 분석 결과&#10;        &quot;&quot;&quot;&#10;        logger.info(&quot;--- 일일 주식 뉴스 분석 시작 ---&quot;)&#10;&#10;        try:&#10;            # 1. 뉴스 및 리포트 크롤링&#10;            logger.info(&quot;1단계: 뉴스 및 리포트 크롤링 시작&quot;)&#10;            crawled_data = self.crawler.get_today_summary()&#10;&#10;            if crawled_data['total_count'] == 0:&#10;                logger.warning(&quot;크롤링된 데이터가 없습니다.&quot;)&#10;                return {&quot;error&quot;: &quot;크롤링된 데이터가 없습니다.&quot;}&#10;&#10;            # 크롤링 현황 출력&#10;            logger.info(f&quot;뉴스 크롤링: {len(crawled_data['main_news'])}개&quot;)&#10;            logger.info(f&quot;리포트 크롤링: {len(crawled_data['research_reports'])}개&quot;)&#10;&#10;            # 카테고리별 통계 출력&#10;            category_counts = {}&#10;            for report in crawled_data['research_reports']:&#10;                category = report.get('category_name', 'Unknown')&#10;                category_counts[category] = category_counts.get(category, 0) + 1&#10;&#10;            if category_counts:&#10;                for category, count in category_counts.items():&#10;                    logger.info(f&quot;  {category}: {count}개&quot;)&#10;&#10;            # 2. AI 분석 수행 (카테고리별 상세 분석 포함)&#10;            logger.info(&quot;Gemini API 분석 시작&quot;)&#10;            analysis_result = self.analyzer.analyze_comprehensive_with_categories(crawled_data)&#10;&#10;            # 3. 결과 저장&#10;            self._save_results(crawled_data, analysis_result)&#10;&#10;            logger.info(&quot;분석 완료&quot;)&#10;&#10;            return {&#10;                'crawled_data': crawled_data,&#10;                'analysis_result': analysis_result,&#10;                'status': 'success'&#10;            }&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;분석 시스템 실행 중 오류: {e}&quot;)&#10;            return {&quot;error&quot;: f&quot;시스템 실행 중 오류: {str(e)}&quot;}&#10;&#10;    def _save_results(self, crawled_data: dict, analysis_result: dict):&#10;        &quot;&quot;&quot;분석 결과를 파일로 저장&quot;&quot;&quot;&#10;        timestamp = datetime.now().strftime(&quot;%Y%m%d_%H%M%S&quot;)&#10;&#10;        # 크롤링 데이터 저장&#10;        with open(f'crawled_data_{timestamp}.json', 'w', encoding='utf-8') as f:&#10;            json.dump(crawled_data, f, ensure_ascii=False, indent=2)&#10;&#10;        # 분석 결과 저장&#10;        with open(f'analysis_result_{timestamp}.json', 'w', encoding='utf-8') as f:&#10;            json.dump(analysis_result, f, ensure_ascii=False, indent=2)&#10;&#10;        logger.info(f&quot;결과 파일 저장 완료: crawled_data_{timestamp}.json, analysis_result_{timestamp}.json&quot;)&#10;&#10;    def print_summary(self, result: dict):&#10;        &quot;&quot;&quot;분석 결과 요약 출력&quot;&quot;&quot;&#10;        if 'error' in result:&#10;            print(f&quot;❌ 오류: {result['error']}&quot;)&#10;            return&#10;&#10;        analysis = result['analysis_result']&#10;&#10;        print(&quot;\n&quot; + &quot;-&quot;*50)&#10;        print(&quot;&lt;오늘의 주식 시장 분석 결과&gt;&quot;)&#10;        print(&quot;-&quot;*50)&#10;&#10;        # 뉴스 분석 요약&#10;        if 'news_analysis' in analysis:&#10;            news = analysis['news_analysis']&#10;            print(f&quot;\n 뉴스 분석 ({news.get('news_count', 0)}개)&quot;)&#10;            print(f&quot;   감정: {news.get('overall_sentiment', 'N/A')}&quot;)&#10;            print(f&quot;   점수: {news.get('sentiment_score', 'N/A')}/100&quot;)&#10;            print(f&quot;   투자신호: {news.get('investment_signals', 'N/A')}&quot;)&#10;            if 'summary' in news:&#10;                print(f&quot;   요약: {news['summary']}&quot;)&#10;&#10;        # 리포트 분석 요약 (카테고리별)&#10;        if 'reports_analysis' in analysis:&#10;            reports = analysis['reports_analysis']&#10;            print(f&quot;\n 리포트 분석 ({reports.get('reports_count', 0)}개)&quot;)&#10;            print(f&quot;   시장 전망: {reports.get('market_outlook', 'N/A')}&quot;)&#10;&#10;            if 'top_mentioned_stocks' in reports:&#10;                stocks = reports['top_mentioned_stocks'][:5]&#10;                if stocks:&#10;                    print(f&quot;   주목 종목: {', '.join(stocks)}&quot;)&#10;&#10;        # 일일 종합 분석 및 매수콜&#10;        if 'daily_report' in analysis:&#10;            daily = analysis['daily_report']&#10;            if 'error' not in daily:&#10;                print(f&quot;\n⭐ 종합 평가&quot;)&#10;                print(f&quot;   시장 감정 점수: {daily.get('market_sentiment_score', 'N/A')}/10&quot;)&#10;                print(f&quot;   신뢰도: {daily.get('confidence_level', 'N/A')}/10&quot;)&#10;                &#10;                # 매수콜 표시&#10;                sentiment_score = analysis.get('news_analysis', {}).get('sentiment_score', 50)&#10;                investment_signal = analysis.get('news_analysis', {}).get('investment_signals', 'hold')&#10;                &#10;                print(f&quot;\n 투자 추천&quot;)&#10;                if sentiment_score &gt;= 70 or investment_signal == 'buy':&#10;                    print(f&quot;    매수 추천 (감정점수: {sentiment_score}/100)&quot;)&#10;                elif sentiment_score &lt;= 30 or investment_signal == 'sell':&#10;                    print(f&quot;    매도 추천 (감정점수: {sentiment_score}/100)&quot;)&#10;                else:&#10;                    print(f&quot;   ⏸️ 관망 추천 (감정점수: {sentiment_score}/100)&quot;)&#10;                &#10;                if 'recommendations' in daily:&#10;                    print(f&quot;   권장사항:&quot;)&#10;                    for rec in daily['recommendations']:&#10;                        print(f&quot;     • {rec}&quot;)&#10;&#10;    def print_detailed_category_analysis(self, result: dict):&#10;        &quot;&quot;&quot;카테고리별 상세 분석 결과 출력&quot;&quot;&quot;&#10;        if 'error' in result or 'category_insights' not in result['analysis_result']:&#10;            return&#10;&#10;        analysis = result['analysis_result']&#10;        insights = analysis['category_insights']&#10;&#10;        if 'category_statistics' in insights:&#10;            print(f&quot;\n&quot; + &quot;-&quot;*50)&#10;            print(&quot;&lt;카테고리별 상세 분석&gt;&quot;)&#10;            print(&quot;-&quot;*50)&#10;&#10;            stats = insights['category_statistics']&#10;            for category, data in stats.items():&#10;                print(f&quot;\n {category}: {data['count']}개 리포트&quot;)&#10;                if data['mentioned_stocks']:&#10;                    print(f&quot;   주요 종목: {', '.join(data['mentioned_stocks'][:3])}&quot;)&#10;                if data['active_firms']:&#10;                    print(f&quot;   주요 증권사: {', '.join(data['active_firms'][:3])}&quot;)&#10;&#10;            if insights.get('most_active_category'):&#10;                print(f&quot;\n 가장 활발한 카테고리: {insights['most_active_category']}&quot;)&#10;&#10;        print(&quot;\n&quot; + &quot;-&quot;*50)&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    try:&#10;        # 분석 시스템 초기화 및 실행&#10;        system = StockNewsAnalysisSystem()&#10;        &#10;        print(&quot;--------------------------------------------------&quot;)&#10;        print(&quot;&lt;오늘의 주식 시장 분석 결과&gt;&quot;)&#10;        print(&quot;--------------------------------------------------&quot;)&#10;        &#10;        # 일일 분석 실행 (뉴스 20개, 리포트 각 카테고리별 5개)&#10;        result = system.run_daily_analysis(news_limit=20, reports_limit=5)&#10;        &#10;        print(&quot;\n--------------------------------------------------&quot;)&#10;        print(&quot;&lt;뉴스 크롤링 완료&gt;&quot;)&#10;        print(&quot;--------------------------------------------------&quot;)&#10;        &#10;        # 분석 결과 요약 출력&#10;        system.print_summary(result)&#10;        &#10;        # 카테고리별 상세 분석 출력&#10;        system.print_detailed_category_analysis(result)&#10;        &#10;        print(&quot;\n분석이 완료되었습니다!&quot;)&#10;        &#10;    except Exception as e:&#10;        print(f&quot;❌ 시스템 실행 중 오류 발생: {e}&quot;)&#10;        import traceback&#10;        traceback.print_exc()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/news_analyzer.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/news_analyzer.py" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;뉴스 및 리서치 분석 모듈 - Gemini API 활용&#10;&quot;&quot;&quot;&#10;&#10;from typing import List, Dict&#10;import json&#10;import logging&#10;from datetime import datetime&#10;from _1st_stage_news_analysis_LLM import client, model_name, ask_question_to_gemini_cache, json_match, create_news_analysis_prompt, create_research_reports_analysis_prompt, create_individual_news_analysis_prompt&#10;&#10;logger = logging.getLogger(__name__)&#10;&#10;class NewsAnalyzer:&#10;    &quot;&quot;&quot;뉴스 및 리서치 리포트 분석기&quot;&quot;&quot;&#10;&#10;    def __init__(self):&#10;        self.client = client&#10;        self.model_name = model_name&#10;&#10;    def analyze_news_sentiment(self, news_data: List[Dict]) -&gt; Dict:&#10;        &quot;&quot;&quot;&#10;        뉴스 감정 분석&#10;&#10;        Args:&#10;            news_data: 뉴스 데이터 리스트&#10;&#10;        Returns:&#10;            Dict: 감정 분석 결과&#10;        &quot;&quot;&quot;&#10;        if not news_data:&#10;            return {&quot;error&quot;: &quot;분석할 뉴스 데이터가 없습니다.&quot;}&#10;&#10;        # 뉴스 제목과 내용을 하나의 텍스트로 결합&#10;        combined_text = &quot;&quot;&#10;        for idx, news in enumerate(news_data, 1):&#10;            combined_text += f&quot;\n\n--- 뉴스 {idx} ---\n&quot;&#10;            combined_text += f&quot;제목: {news.get('title', '')}\n&quot;&#10;            # content가 비어있으면 제목만 사용&#10;            content = news.get('content', '')&#10;            if content.strip():&#10;                combined_text += f&quot;내용: {content[:500]}...\n&quot;&#10;            else:&#10;                combined_text += f&quot;내용: 제목 참조\n&quot;&#10;&#10;        # 통합된 프롬프트 생성 함수 사용&#10;        prompt = create_news_analysis_prompt(combined_text)&#10;&#10;        try:&#10;            response = ask_question_to_gemini_cache(prompt)&#10;&#10;            parsed_result = json_match(response)&#10;&#10;            if parsed_result:&#10;                parsed_result['analyzed_at'] = datetime.now().isoformat()&#10;                parsed_result['news_count'] = len(news_data)&#10;                return parsed_result&#10;            else:&#10;                # JSON 파싱 실패 시 기본값 반환&#10;                return {&#10;                    &quot;overall_sentiment&quot;: &quot;neutral&quot;,&#10;                    &quot;sentiment_score&quot;: 0,&#10;                    &quot;key_themes&quot;: [&quot;분석 실패&quot;],&#10;                    &quot;market_impact&quot;: &quot;JSON 파싱 실패로 상세 분석을 제공할 수 없습니다.&quot;,&#10;                    &quot;summary&quot;: &quot;뉴스 분석 중 오류가 발생했습니다.&quot;,&#10;                    &quot;investment_signals&quot;: &quot;hold&quot;,&#10;                    &quot;analyzed_at&quot;: datetime.now().isoformat(),&#10;                    &quot;news_count&quot;: len(news_data),&#10;                    &quot;error&quot;: &quot;JSON 파싱 실패&quot;&#10;                }&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;뉴스 감정 분석 중 오류: {e}&quot;)&#10;            return {&quot;error&quot;: f&quot;분석 중 오류 발생: {str(e)}&quot;}&#10;&#10;    def analyze_research_reports(self, reports_data: List[Dict]) -&gt; Dict:&#10;        &quot;&quot;&quot;&#10;        리서치 리포트 분석 (개선된 버전 - 카테고리별 분석 포괄)&#10;&#10;        Args:&#10;            reports_data: 리포트 데이터 리스트&#10;&#10;        Returns:&#10;            Dict: 리포트 분석 결과&#10;        &quot;&quot;&quot;&#10;        if not reports_data:&#10;            return {&quot;error&quot;: &quot;분석할 리포트 데이터가 없습니다.&quot;}&#10;&#10;        # 카테고리별로 리포트 분류&#10;        categorized_reports = {}&#10;        for report in reports_data:&#10;            category = report.get('category_name', 'unknown')&#10;            if category not in categorized_reports:&#10;                categorized_reports[category] = []&#10;            categorized_reports[category].append(report)&#10;&#10;        # 분석용 텍스트 생성&#10;        combined_text = self._format_reports_for_analysis(categorized_reports)&#10;&#10;        # 통합된 리서치 리포트 분석 프롬프트 사용&#10;        prompt = create_research_reports_analysis_prompt(combined_text)&#10;&#10;        try:&#10;            response = ask_question_to_gemini_cache(prompt)&#10;&#10;            parsed_result = json_match(response)&#10;&#10;            if parsed_result:&#10;                # 필수 항목이 모두 포함되었는지 검증&#10;                required_fields = [&#10;                    'category_summary', 'top_mentioned_stocks', 'key_industries',&#10;                    'investment_themes', 'market_outlook', 'risk_factors',&#10;                    'opportunities', 'analyst_consensus', 'summary'&#10;                ]&#10;&#10;                # 누락된 필드가 있으면 기본값으로 채우기&#10;                for field in required_fields:&#10;                    if field not in parsed_result:&#10;                        if field == 'category_summary':&#10;                            parsed_result[field] = {&quot;종목분석&quot;: &quot;분석 데이터 부족&quot;, &quot;산업분석&quot;: &quot;분석 데이터 부족&quot;, &quot;시황정보&quot;: &quot;분석 데이터 부족&quot;, &quot;투자정보&quot;: &quot;분석 데이터 부족&quot;}&#10;                        elif field in ['top_mentioned_stocks', 'key_industries', 'investment_themes', 'risk_factors', 'opportunities']:&#10;                            parsed_result[field] = [&quot;데이터 부족&quot;]&#10;                        elif field == 'market_outlook':&#10;                            parsed_result[field] = &quot;neutral&quot;&#10;                        elif field in ['analyst_consensus', 'summary']:&#10;                            parsed_result[field] = &quot;분석 데이터가 부족합니다.&quot;&#10;&#10;                parsed_result['analyzed_at'] = datetime.now().isoformat()&#10;                parsed_result['reports_count'] = len(reports_data)&#10;                parsed_result['category_counts'] = {&#10;                    cat: len(reports) for cat, reports in categorized_reports.items()&#10;                }&#10;                return parsed_result&#10;            else:&#10;                # JSON 파싱 실패 시 기본값 반환&#10;                return {&#10;                    &quot;category_summary&quot;: {&#10;                        &quot;종목분석&quot;: &quot;JSON 파싱 실패로 분석할 수 없습니다.&quot;,&#10;                        &quot;산업분석&quot;: &quot;JSON 파싱 실패로 분석할 수 없습니다.&quot;,&#10;                        &quot;시황정보&quot;: &quot;JSON 파싱 실패로 분석할 수 없습니다.&quot;,&#10;                        &quot;투자정보&quot;: &quot;JSON 파싱 실패로 분석할 수 없습니다.&quot;&#10;                    },&#10;                    &quot;top_mentioned_stocks&quot;: [&quot;분석 실패&quot;],&#10;                    &quot;key_industries&quot;: [&quot;분석 실패&quot;],&#10;                    &quot;investment_themes&quot;: [&quot;분석 실패&quot;],&#10;                    &quot;market_outlook&quot;: &quot;neutral&quot;,&#10;                    &quot;risk_factors&quot;: [&quot;JSON 파싱 실패로 리스크 분석을 제공할 수 없습니다.&quot;],&#10;                    &quot;opportunities&quot;: [&quot;JSON 파싱 실패로 기회 분석을 제공할 수 없습니다.&quot;],&#10;                    &quot;analyst_consensus&quot;: &quot;리포트 분석 중 JSON 파싱 오류가 발생했습니다.&quot;,&#10;                    &quot;summary&quot;: &quot;전체 리포트 분석 중 오류가 발생하여 상세 분석을 제공할 수 없습니다.&quot;,&#10;                    &quot;raw_response&quot;: response,&#10;                    &quot;analyzed_at&quot;: datetime.now().isoformat(),&#10;                    &quot;reports_count&quot;: len(reports_data),&#10;                    &quot;error&quot;: &quot;JSON 파싱 실패&quot;&#10;                }&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;리서치 리포트 분석 중 오류: {e}&quot;)&#10;            return {&quot;error&quot;: f&quot;분석 중 오류 발생: {str(e)}&quot;}&#10;&#10;    def _format_reports_for_analysis(self, categorized_reports: Dict) -&gt; str:&#10;        &quot;&quot;&quot;&#10;        카테고리별 리포트 데이터를 분석할 텍스트로 포맷팅&#10;        &quot;&quot;&quot;&#10;        formatted_text = &quot;&quot;&#10;&#10;        category_names = {&#10;            'stock_analysis': '종목분석 리포트',&#10;            'industry_analysis': '산업분석 리포트',&#10;            'market_info': '시황정보 리포트',&#10;            'investment_info': '투자정보 리포트',&#10;            '종목분석': '종목분석 리포트',&#10;            '산업분석': '산업분석 리포트',&#10;            '시황정보': '시황정보 리포트',&#10;            '투자정보': '투자정보 리포트'&#10;        }&#10;&#10;        for category, reports in categorized_reports.items():&#10;            if reports:&#10;                display_name = category_names.get(category, category)&#10;                formatted_text += f&quot;\n\n=== {display_name} ===\n&quot;&#10;&#10;                for idx, report in enumerate(reports, 1):&#10;                    formatted_text += f&quot;\n{idx}. 제목: {report.get('title', 'N/A')}\n&quot;&#10;&#10;                    if report.get('provider'):&#10;                        formatted_text += f&quot;   증권사: {report['provider']}\n&quot;&#10;&#10;                    if report.get('company'):&#10;                        formatted_text += f&quot;   종목: {report['company']}\n&quot;&#10;&#10;                    # summary가 비어있으면 제목으로 대체&#10;                    summary = report.get('summary', '')&#10;                    if summary.strip() and summary != &quot;요약 내용을 찾을 수 없습니다.&quot;:&#10;                        formatted_text += f&quot;   요약: {summary[:200]}...\n&quot;&#10;                    else:&#10;                        formatted_text += f&quot;   요약: 제목 참조\n&quot;&#10;&#10;                    if report.get('publish_date'):&#10;                        formatted_text += f&quot;   날짜: {report['publish_date']}\n&quot;&#10;&#10;        return formatted_text&#10;&#10;    def analyze_comprehensive_with_categories(self, crawled_data: Dict) -&gt; Dict:&#10;        &quot;&quot;&quot;&#10;        카테고리별 상세 분석을 포함한 종합 분석&#10;&#10;        Args:&#10;            crawled_data: 크롤링된 전체 데이터&#10;&#10;        Returns:&#10;            Dict: 종합 분석 결과 (카테고리별 세부 분석 포함)&#10;        &quot;&quot;&quot;&#10;        logger.info(&quot;카테고리별 상세 종합 분석 시작&quot;)&#10;&#10;        # 전체 뉴스 감정 분석&#10;        news_analysis = self.analyze_news_sentiment(crawled_data.get('main_news', []))&#10;        logger.info(&quot;뉴스 감정 분석 완료&quot;)&#10;&#10;        # 리서치 리포트 분석&#10;        reports_analysis = self.analyze_research_reports(crawled_data.get('research_reports', []))&#10;        logger.info(&quot;리서치 리포트 분석 완료&quot;)&#10;&#10;        # 카테고리별 심화 분석&#10;        category_insights = self._generate_category_insights(crawled_data.get('research_reports', []))&#10;        logger.info(&quot;카테고리별 심화 분석 완료&quot;)&#10;&#10;        # 일일 종합 리포트 생성&#10;        daily_report = self.generate_enhanced_daily_report(news_analysis, reports_analysis, category_insights)&#10;        logger.info(&quot;일일 종합 리포트 생성 완료&quot;)&#10;&#10;        return {&#10;            'news_analysis': news_analysis,&#10;            'reports_analysis': reports_analysis,&#10;            'category_insights': category_insights,&#10;            'daily_report': daily_report,&#10;            'meta': {&#10;                'total_analyzed': len(crawled_data.get('main_news', [])) + len(crawled_data.get('research_reports', [])),&#10;                'analysis_completed_at': datetime.now().isoformat()&#10;            }&#10;        }&#10;&#10;    def _generate_category_insights(self, reports_data: List[Dict]) -&gt; Dict:&#10;        &quot;&quot;&quot;&#10;        카테고리별 심화 인사이트 생성&#10;        &quot;&quot;&quot;&#10;        if not reports_data:&#10;            return {&quot;error&quot;: &quot;분석할 리포트가 없습니다.&quot;}&#10;&#10;        # 카테고리별 통계&#10;        category_stats = {}&#10;        for report in reports_data:&#10;            category = report.get('category_name', 'Unknown')&#10;            if category not in category_stats:&#10;                category_stats[category] = {&#10;                    'count': 0,&#10;                    'firms': set(),&#10;                    'stocks': set(),&#10;                    'recent_titles': []&#10;                }&#10;&#10;            category_stats[category]['count'] += 1&#10;&#10;            if report.get('provider'):&#10;                category_stats[category]['firms'].add(report['provider'])&#10;&#10;            if report.get('company'):&#10;                category_stats[category]['stocks'].add(report['company'])&#10;&#10;            if report.get('title'):&#10;                category_stats[category]['recent_titles'].append(report['title'])&#10;&#10;        # 통계를 JSON 직렬화 가능한 형태로 변환&#10;        formatted_stats = {}&#10;        for category, stats in category_stats.items():&#10;            formatted_stats[category] = {&#10;                'count': stats['count'],&#10;                'active_firms': list(stats['firms'])[:5],  # 최대 5개&#10;                'mentioned_stocks': list(stats['stocks'])[:10],  # 최대 10개&#10;                'sample_titles': stats['recent_titles'][:3]  # 최대 3개&#10;            }&#10;&#10;        return {&#10;            'category_statistics': formatted_stats,&#10;            'total_categories': len(category_stats),&#10;            'most_active_category': max(category_stats.keys(), key=lambda k: category_stats[k]['count']) if category_stats else None,&#10;            'generated_at': datetime.now().isoformat()&#10;        }&#10;&#10;    def generate_enhanced_daily_report(self, news_analysis: Dict, reports_analysis: Dict, category_insights: Dict) -&gt; Dict:&#10;        &quot;&quot;&quot;&#10;        카테고리 인사이트를 포함한 개선된 일일 리포트 생성&#10;        &quot;&quot;&quot;&#10;        # 간단한 점수 계산&#10;        try:&#10;            sentiment_score = news_analysis.get('sentiment_score', 50)&#10;            market_sentiment_score = max(1, min(10, int(sentiment_score / 10)))&#10;            &#10;            return {&#10;                'market_sentiment_score': market_sentiment_score,&#10;                'confidence_level': 7,  # 기본 신뢰도&#10;                'summary': f&quot;뉴스 {news_analysis.get('news_count', 0)}개, 리포트 {reports_analysis.get('reports_count', 0)}개 분석 완료&quot;,&#10;                'recommendations': [&#10;                    &quot;시장 동향을 지속적으로 모니터링하세요&quot;,&#10;                    &quot;리스크 관리를 철저히 하세요&quot;&#10;                ],&#10;                'generated_at': datetime.now().isoformat()&#10;            }&#10;        except Exception as e:&#10;            logger.error(f&quot;일일 리포트 생성 중 오류: {e}&quot;)&#10;            return {&quot;error&quot;: f&quot;일일 리포트 생성 실패: {str(e)}&quot;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/news_crawler.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/news_crawler.py" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;네이버 증권 뉴스 및 리서치 크롤링 모듈&#10;&quot;&quot;&quot;&#10;&#10;import requests&#10;from bs4 import BeautifulSoup&#10;import time&#10;from datetime import datetime&#10;from typing import List, Dict&#10;import logging&#10;&#10;# 로깅 설정 (간단한 진행 상황 표시)&#10;logging.basicConfig(level=logging.INFO, format='%(message)s')&#10;logger = logging.getLogger(__name__)&#10;&#10;class NaverStockNewsCrawler:&#10;    &quot;&quot;&quot;네이버 증권 뉴스 크롤러&quot;&quot;&quot;&#10;&#10;    def __init__(self):&#10;        self.base_url = &quot;https://finance.naver.com&quot;&#10;        self.headers = {&#10;            'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'&#10;        }&#10;        self.session = requests.Session()&#10;        self.session.headers.update(self.headers)&#10;&#10;    def get_main_news(self, limit: int = 10) -&gt; List[Dict]:&#10;        &quot;&quot;&quot;&#10;        네이버 증권 메인 뉴스 크롤링&#10;&#10;        Args:&#10;            limit: 가져올 뉴스 개수&#10;&#10;        Returns:&#10;            List[Dict]: 뉴스 정보 리스트&#10;        &quot;&quot;&quot;&#10;        news_list = []&#10;&#10;        try:&#10;            # 네이버 증권 뉴스 페이지 URL&#10;            url = &quot;https://finance.naver.com/news/&quot;&#10;            response = self.session.get(url)&#10;            response.raise_for_status()&#10;&#10;            soup = BeautifulSoup(response.content, 'html.parser')&#10;&#10;            # 네이버 증권 뉴스 페이지의 다양한 선택자 시도&#10;            news_selectors = [&#10;                '.newslist .articleSubject a',  # 뉴스 리스트의 기사 제목&#10;                '.newsList .articleSubject a',&#10;                '.articleSubject a',            # 기본 기사 제목&#10;                '.news_list .subject a',        # 뉴스 리스트 제목&#10;                '.type2 .subject a',            # type2 스타일의 제목&#10;                '.headline_list .subject a',    # 헤드라인 리스트&#10;                '.articleSubject',              # 제목 요소 자체&#10;                'td.subject a',                 # 테이블 형태의 제목&#10;                '.tb_type1 .subject a',         # 테이블 type1의 제목&#10;                'a[href*=&quot;news_read&quot;]',         # 뉴스 읽기 링크 포함&#10;            ]&#10;&#10;            news_items = []&#10;            found_selector = None&#10;&#10;            for selector in news_selectors:&#10;                try:&#10;                    items = soup.select(selector)&#10;                    if items and len(items) &gt;= 5:  # 최소 5개 이상의 뉴스가 있어야 유효&#10;                        news_items = items[:limit]&#10;                        found_selector = selector&#10;                        logger.info(f&quot;뉴스 리스트 발견: {len(news_items)}개&quot;)&#10;                        break&#10;                except Exception as e:&#10;                    logger.error(f&quot;선택자 '{selector}' 시도 중 오류: {e}&quot;)&#10;                    continue&#10;&#10;            if not news_items:&#10;                # 모든 링크를 찾아서 뉴스 링크 필터링&#10;                logger.info(&quot;기본 선택자 실패, 모든 링크에서 뉴스 링크 찾기 시도...&quot;)&#10;                all_links = soup.find_all('a', href=True)&#10;                news_links = []&#10;&#10;                for link in all_links:&#10;                    href = link.get('href', '')&#10;                    title = link.get_text(strip=True)&#10;&#10;                    # 뉴스 링크 패턴 확인&#10;                    if ('news_read' in href or 'article_id' in href) and title and len(title) &gt; 10:&#10;                        news_links.append(link)&#10;                        if len(news_links) &gt;= limit:&#10;                            break&#10;&#10;                if news_links:&#10;                    news_items = news_links&#10;                    logger.info(f&quot;필터링을 통해 {len(news_items)}�� 뉴스 링크 발견&quot;)&#10;                else:&#10;                    logger.warning(&quot;뉴스 리스트를 찾을 수 없습니다.&quot;)&#10;                    return news_list&#10;&#10;            # 뉴스 항목 처리&#10;            for idx, item in enumerate(news_items):&#10;                try:&#10;                    # 링크 요소 확인&#10;                    if item.name == 'a':&#10;                        title_element = item&#10;                    else:&#10;                        title_element = item.find('a')&#10;&#10;                    if not title_element:&#10;                        continue&#10;&#10;                    title = title_element.get_text(strip=True)&#10;                    link = title_element.get('href')&#10;&#10;                    # 제목이 너무 짧거나 의미없는 경우 스킵&#10;                    if not title or len(title) &lt; 5:&#10;                        continue&#10;&#10;                    # URL 정리 - 스킴 문제 해결&#10;                    if link:&#10;                        if link.startswith('/'):&#10;                            # 상대 경로인 경우&#10;                            link = &quot;https://finance.naver.com&quot; + link&#10;                        elif not link.startswith('http'):&#10;                            # 프로토콜이 없는 경우&#10;                            link = &quot;https://finance.naver.com/&quot; + link.lstrip('/')&#10;&#10;                    # 상세 뉴스 내용 크롤링 (에러가 발생해도 계속 진행)&#10;                    try:&#10;                        news_detail = self._get_news_detail(link)&#10;                    except Exception as detail_error:&#10;                        logger.warning(f&quot;뉴스 상세 크롤링 실패 ('{title}'): {detail_error}&quot;)&#10;                        news_detail = {'content': '', 'publish_date': ''}&#10;&#10;                    news_data = {&#10;                        'title': title,&#10;                        'link': link,&#10;                        'content': news_detail.get('content', ''),&#10;                        'full_html': news_detail.get('full_html', ''),  # HTML 전체 내용 추가&#10;                        'publish_date': news_detail.get('publish_date', ''),&#10;                        'category': 'main_news',&#10;                        'crawled_at': datetime.now().isoformat()&#10;                    }&#10;&#10;                    news_list.append(news_data)&#10;                    logger.info(f&quot;뉴스 수집 ({len(news_list)}/{limit}): '{title[:50]}...'&quot;)&#10;&#10;                    # 원하는 개수에 도달하면 중단&#10;                    if len(news_list) &gt;= limit:&#10;                        break&#10;&#10;                    # 서버 부하 방지를 위한 딜레이&#10;                    time.sleep(0.5)  # 딜레이 단축&#10;&#10;                except Exception as e:&#10;                    logger.error(f&quot;뉴스 항목 처리 중 오류: {e}&quot;)&#10;                    continue&#10;&#10;            logger.info(f&quot;뉴스 크롤링 완료: 총 {len(news_list)}개 수집&quot;)&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;메인 뉴스 크롤링 중 오류: {e}&quot;)&#10;&#10;        return news_list&#10;&#10;    def get_research_reports(self, limit: int = 10) -&gt; List[Dict]:&#10;        &quot;&quot;&quot;&#10;        네이버 증권 리서치 리포트 크롤링 (최신 리포트 수집)&#10;        각 카테고리별 개별 페이지에서 가장 최신 리포트를 수집&#10;&#10;        Args:&#10;            limit: 각 카테고리별로 가져올 리포트 개수&#10;&#10;        Returns:&#10;            List[Dict]: 리포트 정보 리스트&#10;        &quot;&quot;&quot;&#10;        all_reports = []&#10;&#10;        # 각 카테고리별 개별 페이지 URL&#10;        category_urls = {&#10;            '종목분석': f&quot;{self.base_url}/research/company_list.naver&quot;,&#10;            '산업분석': f&quot;{self.base_url}/research/industry_list.naver&quot;,&#10;            '시황정보': f&quot;{self.base_url}/research/market_info_list.naver&quot;,&#10;            '투자정보': f&quot;{self.base_url}/research/invest_list.naver&quot;&#10;        }&#10;&#10;        logger.info(f&quot;각 카테고리별 최신 리포트 {limit}개씩 수집&quot;)&#10;&#10;        for category_name, category_url in category_urls.items():&#10;            try:&#10;                logger.info(f&quot;{category_name} 최신 리포트 크롤링 시작... ({category_url})&quot;)&#10;&#10;                response = self.session.get(category_url)&#10;                response.raise_for_status()&#10;&#10;                soup = BeautifulSoup(response.content, 'html.parser')&#10;&#10;                # 테이블 찾기 - 여러 선택자 시도&#10;                table_selectors = [&#10;                    'table.type_1',&#10;                    'table.type_2',&#10;                    '.board_list table',&#10;                    '.research_list table',&#10;                    'table'&#10;                ]&#10;&#10;                table = None&#10;                for selector in table_selectors:&#10;                    table = soup.select_one(selector)&#10;                    if table:&#10;                        logger.info(f&quot;{category_name} 리포트 발견&quot;)&#10;                        break&#10;&#10;                if not table:&#10;                    logger.warning(f&quot;{category_name}: 테이블을 찾을 수 없습니다.&quot;)&#10;                    continue&#10;&#10;                # 테이블 행 추출&#10;                rows = table.find_all('tr')&#10;                if len(rows) &lt;= 1:  # 헤더만 있는 경우&#10;                    logger.warning(f&quot;{category_name}: 데이터 행이 없습니다.&quot;)&#10;                    continue&#10;&#10;                # 헤더 제외하고 데이터 행 처리&#10;                data_rows = rows[1:] if rows[0].find('th') else rows&#10;&#10;                count = 0&#10;&#10;                # 날짜 필터링 없이 최신 순으로 리��트 수집&#10;                for row in data_rows:&#10;                    if count &gt;= limit:&#10;                        break&#10;&#10;                    cells = row.find_all('td')&#10;                    if len(cells) &lt; 3:  # 최소한의 셀 개수&#10;                        continue&#10;&#10;                    try:&#10;                        # 제목과 링크 찾기&#10;                        title_link = None&#10;                        title = &quot;&quot;&#10;                        link = &quot;&quot;&#10;&#10;                        for cell in cells:&#10;                            a_tag = cell.find('a')&#10;                            if a_tag and a_tag.get('href'):&#10;                                title_link = a_tag&#10;                                title = a_tag.get_text(strip=True)&#10;                                link = a_tag.get('href')&#10;&#10;                                # URL 정리 - 올바�� 프로토콜 수정&#10;                                if not link.startswith('http'):&#10;                                    # 상대 경로인 경우 올바른 기본 경로 추가&#10;                                    if link.startswith('/'):&#10;                                        link = self.base_url + link&#10;                                    else:&#10;                                        # research 경로가 누락된 경우 추가&#10;                                        link = f&quot;{self.base_url}/research/{link}&quot;&#10;                                break&#10;&#10;                        if not title_link or not title:&#10;                            continue&#10;&#10;                        # 발행일 추출 (마지막 셀 또는 날짜가 포함된 셀)&#10;                        publish_date = &quot;&quot;&#10;                        for cell in reversed(cells):  # 뒤에서부터 찾기&#10;                            cell_text = cell.get_text(strip=True)&#10;                            # 날짜 패턴이 있는지 확인&#10;                            if any(char.isdigit() for char in cell_text) and any(sep in cell_text for sep in ['.', '-', '/']):&#10;                                publish_date = cell_text&#10;                                break&#10;&#10;                        # 상세 페이지에서 요약 내용 가져오기&#10;                        summary = self._get_research_detail_summary(link)&#10;&#10;                        # 증권사/제공자 정보 찾기&#10;                        provider = &quot;&quot;&#10;                        for cell in cells:&#10;                            cell_text = cell.get_text(strip=True)&#10;                            if any(keyword in cell_text for keyword in ['증권', '투자', '자산', '캐피탈']):&#10;                                provider = cell_text&#10;                                break&#10;&#10;                        # 회사명 추출 (종목분석의 경우)&#10;                        company = &quot;&quot;&#10;                        if category_name == '종목분석' and len(cells) &gt; 0:&#10;                            company = cells[0].get_text(strip=True)&#10;&#10;                        report_data = {&#10;                            'title': title,&#10;                            'link': link,&#10;                            'summary': summary,&#10;                            'provider': provider,&#10;                            'company': company,&#10;                            'publish_date': publish_date if publish_date else 'unknown',&#10;                            'category_name': category_name,&#10;                            'category_key': category_name.lower(),&#10;                            'crawled_at': datetime.now().isoformat()&#10;                        }&#10;&#10;                        all_reports.append(report_data)&#10;                        count += 1&#10;&#10;                        logger.info(f&quot;{category_name}: '{title}' 리포트 수집 ({count}/{limit})&quot;)&#10;&#10;                        # 서버 부하 방지&#10;                        time.sleep(1)&#10;&#10;                    except Exception as e:&#10;                        logger.error(f&quot;{category_name} 리포트 항목 처리 중 오류: {e}&quot;)&#10;                        continue&#10;&#10;                logger.info(f&quot;{category_name}: {count}개 최신 리포트 수집 완료&quot;)&#10;&#10;                # 카테고리 간 딜레이&#10;                time.sleep(2)&#10;&#10;            except Exception as e:&#10;                logger.error(f&quot;{category_name} 카테고리 크롤링 중 오류: {e}&quot;)&#10;                continue&#10;&#10;        return all_reports&#10;&#10;    def _get_news_detail(self, link: str) -&gt; Dict:&#10;        &quot;&quot;&quot;&#10;        뉴스 상세 내용 크롤링&#10;&#10;        Args:&#10;            link: 뉴스 링크&#10;&#10;        Returns:&#10;            Dict: 뉴스 내용(전체 본문), HTML 컨텐츠, 발행일 등 정보&#10;        &quot;&quot;&quot;&#10;        try:&#10;            response = self.session.get(link)&#10;            response.raise_for_status()&#10;&#10;            soup = BeautifulSoup(response.content, 'html.parser')&#10;&#10;            # 네이버 뉴스 본문 추출 - 여러 선택자 시도&#10;            content = &quot;&quot;&#10;            full_html = &quot;&quot;&#10;&#10;            # 1. dic_area ID를 가진 요소 (네이버 뉴스 표준 형식)&#10;            content_div = soup.find('article', {'id': 'dic_area'})&#10;            if not content_div:&#10;                content_div = soup.find('div', {'id': 'dic_area'})&#10;&#10;            # 2. 다른 일반적인 선택자들 시도&#10;            if not content_div:&#10;                content_div = soup.find('div', {'class': 'article'})&#10;            if not content_div:&#10;                content_div = soup.find('div', {'id': 'articleBody'})&#10;            if not content_div:&#10;                content_div = soup.find('div', {'class': 'newsct_body'})&#10;            if not content_div:&#10;                content_div = soup.find('div', {'class': 'newsct_article'})&#10;&#10;            # 컨텐츠 추출&#10;            if content_div:&#10;                # 텍스트만 추출&#10;                content = content_div.get_text(strip=True)&#10;&#10;                # HTML 전체 내용 저장&#10;                full_html = str(content_div)&#10;&#10;            # 발행일 추출 (메타 태그 또는 기사 본문 내에서 추출 시도)&#10;            publish_date = &quot;&quot;&#10;            date_meta = soup.find('meta', {'property': 'article:published_time'})&#10;            if date_meta and date_meta.get('content'):&#10;                publish_date = date_meta['content']&#10;            else:&#10;                # 본문 내에서 날짜 형식 추출 (예: 2023.03.15. 10:30)&#10;                import re&#10;                date_patterns = [r'(\d{4}[.\-]\d{1,2}[.\-]\d{1,2})', r'(\d{1,2}[.\-]\d{1,2}[.\-]\d{2,4})']&#10;                for pattern in date_patterns:&#10;                    match = re.search(pattern, content)&#10;                    if match:&#10;                        publish_date = match.group(0)&#10;                        break&#10;&#10;            return {&#10;                'content': content,&#10;                'full_html': full_html,&#10;                'publish_date': publish_date&#10;            }&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;뉴스 상세 크롤링 중 오류: {e}&quot;)&#10;            return {}&#10;&#10;    def _get_research_detail_summary(self, link: str) -&gt; str:&#10;        &quot;&quot;&quot;&#10;        리서치 리포트 상세 내용에서 요약 추출&#10;&#10;        Args:&#10;            link: 리포트 링크&#10;&#10;        Returns:&#10;            str: 리포트 요약 내용&#10;        &quot;&quot;&quot;&#10;        try:&#10;            response = self.session.get(link)&#10;            response.raise_for_status()&#10;&#10;            soup = BeautifulSoup(response.content, 'html.parser')&#10;&#10;            # 요약 내용 추출 (일반적으로 'div.summary' 또는 'div#reportSummary'에 요약이 있음)&#10;            summary_div = soup.find('div', {'class': 'summary'})&#10;            if not summary_div:&#10;                summary_div = soup.find('div', {'id': 'reportSummary'})&#10;&#10;            summary = summary_div.get_text(strip=True) if summary_div else &quot;&quot;&#10;&#10;            return summary&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;리포트 요약 크롤링 중 오류: {e}&quot;)&#10;            return &quot;&quot;&#10;&#10;    def get_today_summary(self) -&gt; Dict:&#10;        &quot;&quot;&quot;&#10;        오늘의 주요 뉴스와 리포트 요약 크롤링&#10;&#10;        Returns:&#10;            Dict: 오늘의 뉴스와 리포트 데이터&#10;        &quot;&quot;&quot;&#10;        logger.info(&quot;오늘의 주요 뉴스 크롤링 시작&quot;)&#10;&#10;        # 메인 뉴스 크롤링 (20개로 증가)&#10;        main_news = self.get_main_news(limit=20)&#10;        logger.info(f&quot;메인 뉴스 {len(main_news)}개 수집 완료&quot;)&#10;&#10;        # 리서치 리포트 크롤링 (복구)&#10;        research_reports = self.get_research_reports(limit=5)&#10;        logger.info(f&quot;리서치 리포트 {len(research_reports)}개 수집 완료&quot;)&#10;&#10;        return {&#10;            'main_news': main_news,&#10;            'research_reports': research_reports,&#10;            'crawled_at': datetime.now().isoformat(),&#10;            'total_count': len(main_news) + len(research_reports)&#10;        }&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    # 테스트 실행&#10;    crawler = NaverStockNewsCrawler()&#10;    data = crawler.get_today_summary()&#10;    print(f&quot;총 {data['total_count']}개 뉴스/리포트 수집 완료&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/optimizer/.env.example">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/optimizer/.env.example" />
              <option name="updatedContent" value="# IBM Quantum API Token&#10;# Get your token from: https://quantum-computing.ibm.com/&#10;IBM_QUANTUM_TOKEN=your_ibm_quantum_token_here&#10;&#10;# Example:&#10;# IBM_QUANTUM_TOKEN=abc123def456ghi789jkl012mno345pqr678stu901vwx234yz" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/optimizer/classic_opt.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/optimizer/classic_opt.py" />
              <option name="originalContent" value="import json&#10;import numpy as np&#10;import pandas as pd&#10;import matplotlib.pyplot as plt&#10;import seaborn as sns&#10;from datetime import datetime, timedelta&#10;import yfinance as yf&#10;from scipy.optimize import minimize&#10;import warnings&#10;warnings.filterwarnings('ignore')&#10;&#10;# 한글 폰트 설정&#10;plt.rcParams['font.family'] = 'DejaVu Sans'&#10;plt.rcParams['axes.unicode_minus'] = False&#10;&#10;class PortfolioOptimizer:&#10;    def __init__(self, stock_list, investment_amount, period_years=2):&#10;        &quot;&quot;&quot;&#10;        포트폴리오 최적화 클래스&#10;&#10;        Args:&#10;            stock_list: 기업 리스트 (JSON 형태 또는 리스트)&#10;            investment_amount: 총 투자 금액&#10;            period_years: 과거 데이터 기간 (년)&#10;        &quot;&quot;&quot;&#10;        self.stock_list = self._parse_stock_list(stock_list)&#10;        self.investment_amount = investment_amount&#10;        self.period_years = period_years&#10;        self.stock_data = None&#10;        self.returns = None&#10;        self.mean_returns = None&#10;        self.cov_matrix = None&#10;        self.optimal_weights = None&#10;&#10;    def _parse_stock_list(self, stock_list):&#10;        &quot;&quot;&quot;기업 리스트를 파싱&quot;&quot;&quot;&#10;        if isinstance(stock_list, str):&#10;            try:&#10;                data = json.loads(stock_list)&#10;                if isinstance(data, dict) and 'stocks' in data:&#10;                    # JSON에서 stocks 배열 추출&#10;                    stocks = data['stocks']&#10;                    return [stock.get('symbol', stock.get('code', '')) if isinstance(stock, dict) else str(stock) for stock in stocks]&#10;                elif isinstance(data, list):&#10;                    return [stock.get('symbol', stock.get('code', '')) if isinstance(stock, dict) else str(stock) for stock in data]&#10;                else:&#10;                    return list(data.values()) if isinstance(data, dict) else [str(data)]&#10;            except json.JSONDecodeError:&#10;                return [stock_list]&#10;        elif isinstance(stock_list, dict):&#10;            # 딕셔너리 형태의 입력 처리&#10;            if 'stocks' in stock_list:&#10;                stocks = stock_list['stocks']&#10;                return [stock.get('symbol', stock.get('code', '')) if isinstance(stock, dict) else str(stock) for stock in stocks]&#10;            else:&#10;                return list(stock_list.values())&#10;        elif isinstance(stock_list, list):&#10;            return [stock.get('symbol', stock.get('code', '')) if isinstance(stock, dict) else str(stock) for stock in stock_list]&#10;        else:&#10;            return [str(stock_list)]&#10;&#10;    def fetch_stock_data(self):&#10;        &quot;&quot;&quot;2년치 과거 종가 데이터 수집&quot;&quot;&quot;&#10;        end_date = datetime.now()&#10;        start_date = end_date - timedelta(days=self.period_years * 365)&#10;&#10;        # 한국 주식 코드 처리 (.KS 추가)&#10;        symbols = []&#10;        for stock in self.stock_list:&#10;            if isinstance(stock, dict):&#10;                symbol = stock.get('symbol', stock.get('code', ''))&#10;            else:&#10;                symbol = str(stock)&#10;&#10;            # 빈 문자열 제거&#10;            if not symbol or symbol.strip() == '':&#10;                continue&#10;&#10;            # 한국 주식인 경우 .KS 추가&#10;            if symbol.isdigit() and len(symbol) == 6:&#10;                symbol += '.KS'&#10;            symbols.append(symbol)&#10;&#10;        if not symbols:&#10;            print(&quot;유효한 주식 코드가 없습니다.&quot;)&#10;            return False&#10;&#10;        print(f&quot;데이터 수집 중: {symbols}&quot;)&#10;&#10;        try:&#10;            # 개별 주식별로 데이터 수집하여 안정성 확보&#10;            stock_prices = {}&#10;&#10;            for symbol in symbols:&#10;                try:&#10;                    print(f&quot;  - {symbol} 데이터 수집 중...&quot;)&#10;                    ticker = yf.Ticker(symbol)&#10;                    hist = ticker.history(start=start_date, end=end_date)&#10;&#10;                    if not hist.empty:&#10;                        # Close 가격 사용 (Adj Close가 없을 수도 있음)&#10;                        if 'Close' in hist.columns:&#10;                            stock_prices[symbol] = hist['Close']&#10;                        elif len(hist.columns) &gt; 0:&#10;                            stock_prices[symbol] = hist.iloc[:, 0]  # 첫 번째 컬럼 사용&#10;                        print(f&quot;    ✓ {symbol}: {len(hist)} 개 데이터 수집 완료&quot;)&#10;                    else:&#10;                        print(f&quot;    ✗ {symbol}: 데이터 없음&quot;)&#10;&#10;                except Exception as e:&#10;                    print(f&quot;    ✗ {symbol}: 수집 실패 - {e}&quot;)&#10;                    continue&#10;&#10;            if not stock_prices:&#10;                raise ValueError(&quot;수집된 주식 데이터가 없습니다.&quot;)&#10;&#10;            # DataFrame으로 변환&#10;            self.stock_data = pd.DataFrame(stock_prices)&#10;&#10;            # 결측치 처리 - 모든 주식에 대해 데이터가 있는 날짜만 사용&#10;            self.stock_data = self.stock_data.dropna()&#10;&#10;            if self.stock_data.empty:&#10;                raise ValueError(&quot;결측치 제거 후 데이터가 없습니다.&quot;)&#10;&#10;            print(f&quot;\n데이터 수집 완료!&quot;)&#10;            print(f&quot;  - 최종 데이터 형태: {self.stock_data.shape}&quot;)&#10;            print(f&quot;  - 수집된 종목: {list(self.stock_data.columns)}&quot;)&#10;            print(f&quot;  - 데이터 기간: {self.stock_data.index[0].date()} ~ {self.stock_data.index[-1].date()}&quot;)&#10;            print(f&quot;  - 총 거래일: {len(self.stock_data)} 일&quot;)&#10;&#10;            return True&#10;&#10;        except Exception as e:&#10;            print(f&quot;데이터 수집 실패: {e}&quot;)&#10;            import traceback&#10;            print(f&quot;상세 오류:\n{traceback.format_exc()}&quot;)&#10;            return False&#10;&#10;    def calculate_returns(self):&#10;        &quot;&quot;&quot;일일 수익률 계산&quot;&quot;&quot;&#10;        if self.stock_data is None:&#10;            raise ValueError(&quot;먼저 데이터를 수집해주세요.&quot;)&#10;&#10;        self.returns = self.stock_data.pct_change().dropna()&#10;        self.mean_returns = self.returns.mean() * 252  # 연간 수익률&#10;        self.cov_matrix = self.returns.cov() * 252  # 연간 공분산&#10;&#10;        print(&quot;수익률 계산 완료&quot;)&#10;        print(f&quot;연간 평균 수익률:\n{self.mean_returns}&quot;)&#10;&#10;    def portfolio_stats(self, weights):&#10;        &quot;&quot;&quot;포트폴리오 통계 계산&quot;&quot;&quot;&#10;        portfolio_return = np.sum(weights * self.mean_returns)&#10;        portfolio_volatility = np.sqrt(np.dot(weights.T, np.dot(self.cov_matrix, weights)))&#10;        sharpe_ratio = portfolio_return / portfolio_volatility&#10;        return portfolio_return, portfolio_volatility, sharpe_ratio&#10;&#10;    def negative_sharpe(self, weights):&#10;        &quot;&quot;&quot;샤프 비율의 음수 (최적화를 위해)&quot;&quot;&quot;&#10;        return -self.portfolio_stats(weights)[2]&#10;&#10;    def optimize_portfolio(self):&#10;        &quot;&quot;&quot;포트폴리오 최적화 (최대 샤프 ��율)&quot;&quot;&quot;&#10;        if self.returns is None:&#10;            raise ValueError(&quot;먼저 수익률을 계산해주세요.&quot;)&#10;&#10;        num_assets = len(self.mean_returns)&#10;&#10;        # 제약 조건&#10;        constraints = ({'type': 'eq', 'fun': lambda x: np.sum(x) - 1})&#10;        bounds = tuple((0, 1) for _ in range(num_assets))&#10;&#10;        # 초기 추정값 (균등 분배)&#10;        initial_guess = num_assets * [1. / num_assets]&#10;&#10;        # 최적화 실행&#10;        result = minimize(&#10;            self.negative_sharpe,&#10;            initial_guess,&#10;            method='SLSQP',&#10;            bounds=bounds,&#10;            constraints=constraints&#10;        )&#10;&#10;        if result.success:&#10;            self.optimal_weights = result.x&#10;            print(&quot;포트폴리오 최적화 완료&quot;)&#10;            return True&#10;        else:&#10;            print(&quot;최적화 실패&quot;)&#10;            return False&#10;&#10;    def calculate_allocation(self):&#10;        &quot;&quot;&quot;각 기업별 투자 금액 계산&quot;&quot;&quot;&#10;        if self.optimal_weights is None:&#10;            raise ValueError(&quot;먼저 포트폴리오를 최적화해주세요.&quot;)&#10;&#10;        allocations = []&#10;        symbols = list(self.stock_data.columns)&#10;&#10;        for i, weight in enumerate(self.optimal_weights):&#10;            symbol = symbols[i].replace('.KS', '')  # .KS 제거&#10;            amount = self.investment_amount * weight&#10;            allocations.append({&#10;                'symbol': symbol,&#10;                'weight': weight,&#10;                'amount': int(amount),&#10;                'percentage': weight * 100&#10;            })&#10;&#10;        # 가중치가 높은 순으로 정렬&#10;        allocations.sort(key=lambda x: x['weight'], reverse=True)&#10;&#10;        return allocations&#10;&#10;    def monte_carlo_simulation(self, num_simulations=10000):&#10;        &quot;&quot;&quot;몬테카를로 시뮬레이션&quot;&quot;&quot;&#10;        if self.returns is None:&#10;            raise ValueError(&quot;먼저 수익률을 계산해주세요.&quot;)&#10;&#10;        num_assets = len(self.mean_returns)&#10;        results = np.zeros((3, num_simulations))&#10;&#10;        for i in range(num_simulations):&#10;            # 랜��� 가중치 생성&#10;            weights = np.random.random(num_assets)&#10;            weights /= np.sum(weights)&#10;&#10;            # 포트폴리오 성과 계산&#10;            portfolio_return, portfolio_volatility, sharpe_ratio = self.portfolio_stats(weights)&#10;&#10;            results[0, i] = portfolio_return&#10;            results[1, i] = portfolio_volatility&#10;            results[2, i] = sharpe_ratio&#10;&#10;        return results&#10;&#10;    def create_visualizations(self, output_dir='./'):&#10;        &quot;&quot;&quot;시각화 생성&quot;&quot;&quot;&#10;        if self.optimal_weights is None:&#10;            raise ValueError(&quot;먼저 포트폴리오를 최적화해주세요.&quot;)&#10;&#10;        # 1. 효율적 프론티어와 몬테카를로 시뮬레이션&#10;        fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(16, 12))&#10;&#10;        # 몬테카를로 시뮬레이션&#10;        mc_results = self.monte_carlo_simulation()&#10;&#10;        # 효율적 프론티어 점 그래프&#10;        scatter = ax1.scatter(mc_results[1], mc_results[0], c=mc_results[2],&#10;                            cmap='viridis', alpha=0.5, s=1)&#10;&#10;        # 최적 포트폴리오 표시&#10;        opt_return, opt_volatility, opt_sharpe = self.portfolio_stats(self.optimal_weights)&#10;        ax1.scatter(opt_volatility, opt_return, color='red', s=100, marker='*',&#10;                   label=f'Optimal Portfolio (Sharpe: {opt_sharpe:.3f})')&#10;&#10;        ax1.set_xlabel('Volatility (Risk)')&#10;        ax1.set_ylabel('Expected Return')&#10;        ax1.set_title('Efficient Frontier with Monte Carlo Simulation')&#10;        ax1.legend()&#10;        ax1.grid(True, alpha=0.3)&#10;        plt.colorbar(scatter, ax=ax1, label='Sharpe Ratio')&#10;&#10;        # 2. 포트폴리오 구성 비율 (파이 차트)&#10;        symbols = [col.replace('.KS', '') for col in self.stock_data.columns]&#10;        significant_weights = [(symbols[i], weight) for i, weight in enumerate(self.optimal_weights) if weight &gt; 0.01]&#10;&#10;        if len(significant_weights) &gt; 0:&#10;            labels, weights = zip(*significant_weights)&#10;            ax2.pie(weights, labels=labels, autopct='%1.1f%%', startangle=90)&#10;            ax2.set_title('Optimal Portfolio Allocation')&#10;&#10;        # 3. 상관관계 히트맵&#10;        correlation_matrix = self.returns.corr()&#10;        correlation_matrix.columns = [col.replace('.KS', '') for col in correlation_matrix.columns]&#10;        correlation_matrix.index = [idx.replace('.KS', '') for idx in correlation_matrix.index]&#10;&#10;        sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', center=0,&#10;                   square=True, ax=ax3, fmt='.2f')&#10;        ax3.set_title('Stock Correlation Matrix')&#10;&#10;        # 4. 개별 주식 가격 변화&#10;        normalized_prices = self.stock_data / self.stock_data.iloc[0]&#10;        for col in normalized_prices.columns:&#10;            ax4.plot(normalized_prices.index, normalized_prices[col],&#10;                    label=col.replace('.KS', ''), alpha=0.8)&#10;&#10;        ax4.set_xlabel('Date')&#10;        ax4.set_ylabel('Normalized Price')&#10;        ax4.set_title('Stock Price Performance (Normalized)')&#10;        ax4.legend(bbox_to_anchor=(1.05, 1), loc='upper left')&#10;        ax4.grid(True, alpha=0.3)&#10;&#10;        plt.tight_layout()&#10;&#10;        # 파일 저장&#10;        timestamp = datetime.now().strftime(&quot;%Y%m%d_%H%M%S&quot;)&#10;        filename = f&quot;{output_dir}/portfolio_analysis_{timestamp}.png&quot;&#10;        plt.savefig(filename, dpi=300, bbox_inches='tight')&#10;        plt.close()&#10;&#10;        print(f&quot;시각화 저장 완료: {filename}&quot;)&#10;        return filename&#10;&#10;    def run_optimization(self):&#10;        &quot;&quot;&quot;전체 최적화 프로세스 실행&quot;&quot;&quot;&#10;        print(&quot;=== 포트폴리오 최적화 시작 ===&quot;)&#10;&#10;        # 1. 데이터 수집&#10;        if not self.fetch_stock_data():&#10;            return None&#10;&#10;        # 2. 수익률 계산&#10;        self.calculate_returns()&#10;&#10;        # 3. 포트폴리오 최적화&#10;        if not self.optimize_portfolio():&#10;            return None&#10;&#10;        # 4. 투자 금액 계산&#10;        allocations = self.calculate_allocation()&#10;&#10;        # 5. 시각화 생성&#10;        chart_file = self.create_visualizations()&#10;&#10;        # 6. 결과 출력&#10;        print(&quot;\n=== 최적화 결과 ===&quot;)&#10;        opt_return, opt_volatility, opt_sharpe = self.portfolio_stats(self.optimal_weights)&#10;        print(f&quot;예상 연간 수익률: {opt_return:.2%}&quot;)&#10;        print(f&quot;예상 연간 변동성: {opt_volatility:.2%}&quot;)&#10;        print(f&quot;샤프 비율: {opt_sharpe:.3f}&quot;)&#10;&#10;        print(f&quot;\n총 투자 금액: {self.investment_amount:,}원&quot;)&#10;        print(&quot;\n=== 투자 배분 ===&quot;)&#10;        for allocation in allocations:&#10;            if allocation['weight'] &gt; 0.001:  # 0.1% 이상만 표시&#10;                print(f&quot;{allocation['symbol']}: {allocation['amount']:,}원 ({allocation['percentage']:.1f}%)&quot;)&#10;&#10;        return {&#10;            'allocations': allocations,&#10;            'performance': {&#10;                'expected_return': opt_return,&#10;                'volatility': opt_volatility,&#10;                'sharpe_ratio': opt_sharpe&#10;            },&#10;            'chart_file': chart_file&#10;        }&#10;&#10;&#10;def optimize_portfolio_from_json(json_file_path, investment_amount):&#10;    &quot;&quot;&quot;JSON 파일에서 기업 리스트를 읽어 포트폴리오 최적화 실행&quot;&quot;&quot;&#10;    try:&#10;        with open(json_file_path, 'r', encoding='utf-8') as f:&#10;            stock_data = json.load(f)&#10;&#10;        optimizer = PortfolioOptimizer(stock_data, investment_amount)&#10;        return optimizer.run_optimization()&#10;&#10;    except Exception as e:&#10;        print(f&quot;에러 발생: {e}&quot;)&#10;        return None&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    # 테스트용 예제&#10;    test_stocks = [&quot;005930&quot;, &quot;000660&quot;, &quot;035420&quot;, &quot;051910&quot;, &quot;068270&quot;]  # 삼성전자, SK하��닉스, 네이버, LG화학, 셀트리온&#10;    investment_amount = 10000000  # 1천만원&#10;&#10;    optimizer = PortfolioOptimizer(test_stocks, investment_amount)&#10;    result = optimizer.run_optimization()&#10;&#10;    if result:&#10;        print(&quot;\n포트폴리오 최적화 완료!&quot;)&#10;        print(f&quot;차트 파일: {result['chart_file']}&quot;)&#10;" />
              <option name="updatedContent" value="import json&#10;import numpy as np&#10;import pandas as pd&#10;import matplotlib.pyplot as plt&#10;import seaborn as sns&#10;from datetime import datetime, timedelta&#10;import yfinance as yf&#10;from scipy.optimize import minimize&#10;import warnings&#10;warnings.filterwarnings('ignore')&#10;&#10;# 한글 폰트 설정&#10;plt.rcParams['font.family'] = 'DejaVu Sans'&#10;plt.rcParams['axes.unicode_minus'] = False&#10;&#10;class PortfolioOptimizer:&#10;    def __init__(self, stock_list, investment_amount, period_years=2):&#10;        &quot;&quot;&quot;&#10;        포트폴리오 최적화 클래스&#10;&#10;        Args:&#10;            stock_list: 기업 리스트 (JSON 형태 또는 리스트)&#10;            investment_amount: 총 투자 금액&#10;            period_years: 과거 데이터 기간 (년)&#10;        &quot;&quot;&quot;&#10;        self.stock_list = self._parse_stock_list(stock_list)&#10;        self.investment_amount = investment_amount&#10;        self.period_years = period_years&#10;        self.stock_data = None&#10;        self.returns = None&#10;        self.mean_returns = None&#10;        self.cov_matrix = None&#10;        self.optimal_weights = None&#10;&#10;    def _parse_stock_list(self, stock_list):&#10;        &quot;&quot;&quot;기업 리스트를 파싱&quot;&quot;&quot;&#10;        if isinstance(stock_list, str):&#10;            try:&#10;                data = json.loads(stock_list)&#10;                if isinstance(data, dict) and 'stocks' in data:&#10;                    # JSON에서 stocks 배열 추출&#10;                    stocks = data['stocks']&#10;                    return [stock.get('symbol', stock.get('code', '')) if isinstance(stock, dict) else str(stock) for stock in stocks]&#10;                elif isinstance(data, list):&#10;                    return [stock.get('symbol', stock.get('code', '')) if isinstance(stock, dict) else str(stock) for stock in data]&#10;                else:&#10;                    return list(data.values()) if isinstance(data, dict) else [str(data)]&#10;            except json.JSONDecodeError:&#10;                return [stock_list]&#10;        elif isinstance(stock_list, dict):&#10;            # 딕셔너리 형태의 입력 처리&#10;            if 'stocks' in stock_list:&#10;                stocks = stock_list['stocks']&#10;                return [stock.get('symbol', stock.get('code', '')) if isinstance(stock, dict) else str(stock) for stock in stocks]&#10;            else:&#10;                return list(stock_list.values())&#10;        elif isinstance(stock_list, list):&#10;            return [stock.get('symbol', stock.get('code', '')) if isinstance(stock, dict) else str(stock) for stock in stock_list]&#10;        else:&#10;            return [str(stock_list)]&#10;&#10;    def fetch_stock_data(self):&#10;        &quot;&quot;&quot;2년치 과거 종가 데이터 수집&quot;&quot;&quot;&#10;        end_date = datetime.now()&#10;        start_date = end_date - timedelta(days=self.period_years * 365)&#10;&#10;        # 한국 주식 코드 처리 (.KS 추가)&#10;        symbols = []&#10;        for stock in self.stock_list:&#10;            if isinstance(stock, dict):&#10;                symbol = stock.get('symbol', stock.get('code', ''))&#10;            else:&#10;                symbol = str(stock)&#10;&#10;            # 빈 문자열 제거&#10;            if not symbol or symbol.strip() == '':&#10;                continue&#10;&#10;            # 한국 주식인 경우 .KS 추가&#10;            if symbol.isdigit() and len(symbol) == 6:&#10;                symbol += '.KS'&#10;            symbols.append(symbol)&#10;&#10;        if not symbols:&#10;            print(&quot;유효한 주식 코드가 없습니다.&quot;)&#10;            return False&#10;&#10;        print(f&quot;데이터 수집 중: {symbols}&quot;)&#10;&#10;        try:&#10;            # 개별 주식별로 데이터 수집하여 안정성 확보&#10;            stock_prices = {}&#10;&#10;            for symbol in symbols:&#10;                try:&#10;                    print(f&quot;  - {symbol} 데이터 수집 중...&quot;)&#10;                    ticker = yf.Ticker(symbol)&#10;                    hist = ticker.history(start=start_date, end=end_date)&#10;&#10;                    if not hist.empty:&#10;                        # Close 가격 사용 (Adj Close가 없을 수도 있음)&#10;                        if 'Close' in hist.columns:&#10;                            stock_prices[symbol] = hist['Close']&#10;                        elif len(hist.columns) &gt; 0:&#10;                            stock_prices[symbol] = hist.iloc[:, 0]  # 첫 번째 컬럼 사용&#10;                        print(f&quot;    ✓ {symbol}: {len(hist)} 개 데이터 수집 완료&quot;)&#10;                    else:&#10;                        print(f&quot;    ✗ {symbol}: 데이터 없음&quot;)&#10;&#10;                except Exception as e:&#10;                    print(f&quot;    ✗ {symbol}: 수집 실패 - {e}&quot;)&#10;                    continue&#10;&#10;            if not stock_prices:&#10;                raise ValueError(&quot;수집된 주식 데이터가 없습니다.&quot;)&#10;&#10;            # DataFrame으로 변환&#10;            self.stock_data = pd.DataFrame(stock_prices)&#10;&#10;            # 결측치 처리 - 모든 주식에 대해 데이터가 있는 날짜만 사용&#10;            self.stock_data = self.stock_data.dropna()&#10;&#10;            if self.stock_data.empty:&#10;                raise ValueError(&quot;결측치 제거 후 데이터가 없습니다.&quot;)&#10;&#10;            print(f&quot;\n데이터 수집 완료!&quot;)&#10;            print(f&quot;  - 최종 데이터 형태: {self.stock_data.shape}&quot;)&#10;            print(f&quot;  - 수집된 종목: {list(self.stock_data.columns)}&quot;)&#10;            print(f&quot;  - 데이터 기간: {self.stock_data.index[0].date()} ~ {self.stock_data.index[-1].date()}&quot;)&#10;            print(f&quot;  - 총 거래일: {len(self.stock_data)} 일&quot;)&#10;&#10;            return True&#10;&#10;        except Exception as e:&#10;            print(f&quot;데이터 수집 실패: {e}&quot;)&#10;            import traceback&#10;            print(f&quot;상세 오류:\n{traceback.format_exc()}&quot;)&#10;            return False&#10;&#10;    def calculate_returns(self):&#10;        &quot;&quot;&quot;일일 수익률 계산&quot;&quot;&quot;&#10;        if self.stock_data is None:&#10;            raise ValueError(&quot;먼저 데이터를 수집해주세요.&quot;)&#10;&#10;        self.returns = self.stock_data.pct_change().dropna()&#10;        self.mean_returns = self.returns.mean() * 252  # 연간 수익률&#10;        self.cov_matrix = self.returns.cov() * 252  # 연간 공분산&#10;&#10;        print(&quot;수익률 계산 완료&quot;)&#10;        print(f&quot;연간 평균 수익률:\n{self.mean_returns}&quot;)&#10;&#10;    def portfolio_stats(self, weights):&#10;        &quot;&quot;&quot;포트폴리오 통계 계산&quot;&quot;&quot;&#10;        portfolio_return = np.sum(weights * self.mean_returns)&#10;        portfolio_volatility = np.sqrt(np.dot(weights.T, np.dot(self.cov_matrix, weights)))&#10;        sharpe_ratio = portfolio_return / portfolio_volatility&#10;        return portfolio_return, portfolio_volatility, sharpe_ratio&#10;&#10;    def negative_sharpe(self, weights):&#10;        &quot;&quot;&quot;샤프 비율의 음수 (최적화를 위해)&quot;&quot;&quot;&#10;        return -self.portfolio_stats(weights)[2]&#10;&#10;    def optimize_portfolio(self):&#10;        &quot;&quot;&quot;포트폴리오 최적화 (최대 샤프 ��율)&quot;&quot;&quot;&#10;        if self.returns is None:&#10;            raise ValueError(&quot;먼저 수익률을 계산해주세요.&quot;)&#10;&#10;        num_assets = len(self.mean_returns)&#10;&#10;        # 제약 조건&#10;        constraints = ({'type': 'eq', 'fun': lambda x: np.sum(x) - 1})&#10;        bounds = tuple((0, 1) for _ in range(num_assets))&#10;&#10;        # 초기 추정값 (균등 분배)&#10;        initial_guess = num_assets * [1. / num_assets]&#10;&#10;        # 최적화 실행&#10;        result = minimize(&#10;            self.negative_sharpe,&#10;            initial_guess,&#10;            method='SLSQP',&#10;            bounds=bounds,&#10;            constraints=constraints&#10;        )&#10;&#10;        if result.success:&#10;            self.optimal_weights = result.x&#10;            print(&quot;포트폴리오 최적화 완료&quot;)&#10;            return True&#10;        else:&#10;            print(&quot;최적화 실패&quot;)&#10;            return False&#10;&#10;    def get_stock_name(self, symbol):&#10;        &quot;&quot;&quot;주식 코드로부터 종목명 가져오기&quot;&quot;&quot;&#10;        try:&#10;            # .KS가 붙어있으면 제거&#10;            clean_symbol = symbol.replace('.KS', '')&#10;            &#10;            # 주요 종목 매핑&#10;            stock_names = {&#10;                '005930': '삼성전자',&#10;                '000660': 'SK하이닉스', &#10;                '035420': '네이버',&#10;                '051910': 'LG화학',&#10;                '068270': '셀트리온',&#10;                '005380': '현대차',&#10;                '006400': '삼성SDI',&#10;                '035720': '카카오',&#10;                '207940': '삼성바이오로직스',&#10;                '005490': 'POSCO홀딩스'&#10;            }&#10;            &#10;            if clean_symbol in stock_names:&#10;                return stock_names[clean_symbol]&#10;            &#10;            # yfinance로 종목명 가져오기 시도&#10;            try:&#10;                ticker = yf.Ticker(symbol)&#10;                info = ticker.info&#10;                if 'longName' in info:&#10;                    return info['longName']&#10;                elif 'shortName' in info:&#10;                    return info['shortName']&#10;            except:&#10;                pass&#10;                &#10;            # 기본값으로 심볼 반환&#10;            return clean_symbol&#10;            &#10;        except Exception as e:&#10;            return symbol.replace('.KS', '')&#10;&#10;    def calculate_allocation(self):&#10;        &quot;&quot;&quot;각 기업별 투자 금액 계산&quot;&quot;&quot;&#10;        if self.optimal_weights is None:&#10;            raise ValueError(&quot;먼저 포트폴리오를 최적화해주세요.&quot;)&#10;&#10;        allocations = []&#10;        symbols = list(self.stock_data.columns)&#10;&#10;        for i, weight in enumerate(self.optimal_weights):&#10;            symbol = symbols[i].replace('.KS', '')  # .KS 제거&#10;            name = self.get_stock_name(symbols[i])  # 종목명 가져오기&#10;            amount = self.investment_amount * weight&#10;            allocations.append({&#10;                'symbol': symbol,&#10;                'name': name,  # 종목명 추가&#10;                'weight': weight,&#10;                'amount': int(amount),&#10;                'percentage': weight * 100&#10;            })&#10;&#10;        # 가중치가 높은 순으로 정렬&#10;        allocations.sort(key=lambda x: x['weight'], reverse=True)&#10;&#10;        return allocations&#10;&#10;    def monte_carlo_simulation(self, num_simulations=10000):&#10;        &quot;&quot;&quot;몬테카를로 시뮬레이션&quot;&quot;&quot;&#10;        if self.returns is None:&#10;            raise ValueError(&quot;먼저 수익률을 계산해주세요.&quot;)&#10;&#10;        num_assets = len(self.mean_returns)&#10;        results = np.zeros((3, num_simulations))&#10;&#10;        for i in range(num_simulations):&#10;            # 랜��� 가중치 생성&#10;            weights = np.random.random(num_assets)&#10;            weights /= np.sum(weights)&#10;&#10;            # 포트폴리오 성과 계산&#10;            portfolio_return, portfolio_volatility, sharpe_ratio = self.portfolio_stats(weights)&#10;&#10;            results[0, i] = portfolio_return&#10;            results[1, i] = portfolio_volatility&#10;            results[2, i] = sharpe_ratio&#10;&#10;        return results&#10;&#10;    def create_visualizations(self, output_dir='./'):&#10;        &quot;&quot;&quot;시각화 생성&quot;&quot;&quot;&#10;        if self.optimal_weights is None:&#10;            raise ValueError(&quot;먼저 포트폴리오를 최적화해주세요.&quot;)&#10;&#10;        # 1. 효율적 프론티어와 몬테카를로 시뮬레이션&#10;        fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(16, 12))&#10;&#10;        # 몬테카를로 시뮬레이션&#10;        mc_results = self.monte_carlo_simulation()&#10;&#10;        # 효율적 프론티어 점 그래프&#10;        scatter = ax1.scatter(mc_results[1], mc_results[0], c=mc_results[2],&#10;                            cmap='viridis', alpha=0.5, s=1)&#10;&#10;        # 최적 포트폴리오 표시&#10;        opt_return, opt_volatility, opt_sharpe = self.portfolio_stats(self.optimal_weights)&#10;        ax1.scatter(opt_volatility, opt_return, color='red', s=100, marker='*',&#10;                   label=f'Optimal Portfolio (Sharpe: {opt_sharpe:.3f})')&#10;&#10;        ax1.set_xlabel('Volatility (Risk)')&#10;        ax1.set_ylabel('Expected Return')&#10;        ax1.set_title('Efficient Frontier with Monte Carlo Simulation')&#10;        ax1.legend()&#10;        ax1.grid(True, alpha=0.3)&#10;        plt.colorbar(scatter, ax=ax1, label='Sharpe Ratio')&#10;&#10;        # 2. 포트폴리오 구성 비율 (파이 차트)&#10;        symbols = [col.replace('.KS', '') for col in self.stock_data.columns]&#10;        significant_weights = [(symbols[i], weight) for i, weight in enumerate(self.optimal_weights) if weight &gt; 0.01]&#10;&#10;        if len(significant_weights) &gt; 0:&#10;            labels, weights = zip(*significant_weights)&#10;            ax2.pie(weights, labels=labels, autopct='%1.1f%%', startangle=90)&#10;            ax2.set_title('Optimal Portfolio Allocation')&#10;&#10;        # 3. 상관관계 히트맵&#10;        correlation_matrix = self.returns.corr()&#10;        correlation_matrix.columns = [col.replace('.KS', '') for col in correlation_matrix.columns]&#10;        correlation_matrix.index = [idx.replace('.KS', '') for idx in correlation_matrix.index]&#10;&#10;        sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', center=0,&#10;                   square=True, ax=ax3, fmt='.2f')&#10;        ax3.set_title('Stock Correlation Matrix')&#10;&#10;        # 4. 개별 주식 가격 변화&#10;        normalized_prices = self.stock_data / self.stock_data.iloc[0]&#10;        for col in normalized_prices.columns:&#10;            ax4.plot(normalized_prices.index, normalized_prices[col],&#10;                    label=col.replace('.KS', ''), alpha=0.8)&#10;&#10;        ax4.set_xlabel('Date')&#10;        ax4.set_ylabel('Normalized Price')&#10;        ax4.set_title('Stock Price Performance (Normalized)')&#10;        ax4.legend(bbox_to_anchor=(1.05, 1), loc='upper left')&#10;        ax4.grid(True, alpha=0.3)&#10;&#10;        plt.tight_layout()&#10;&#10;        # 파일 저장&#10;        timestamp = datetime.now().strftime(&quot;%Y%m%d_%H%M%S&quot;)&#10;        filename = f&quot;{output_dir}/portfolio_analysis_{timestamp}.png&quot;&#10;        plt.savefig(filename, dpi=300, bbox_inches='tight')&#10;        plt.close()&#10;&#10;        print(f&quot;시각화 저장 완료: {filename}&quot;)&#10;        return filename&#10;&#10;    def run_optimization(self):&#10;        &quot;&quot;&quot;전체 최적화 프로세스 실행&quot;&quot;&quot;&#10;        print(&quot;=== 포트폴리오 최적화 시작 ===&quot;)&#10;&#10;        try:&#10;            # 1. 데이터 수집&#10;            if not self.fetch_stock_data():&#10;                print(&quot;데이터 수집 실패&quot;)&#10;                return None&#10;&#10;            # 2. 수익률 계산&#10;            self.calculate_returns()&#10;&#10;            # 3. 포트폴리오 최적화&#10;            if not self.optimize_portfolio():&#10;                print(&quot;포트폴리오 최적화 실패&quot;)&#10;                return None&#10;&#10;            # 4. 투자 금액 계산&#10;            allocations = self.calculate_allocation()&#10;&#10;            # 5. 시각화 생성&#10;            chart_file = self.create_visualizations()&#10;&#10;            # 6. 결과 출력&#10;            print(&quot;\n=== 최적화 결과 ===&quot;)&#10;            opt_return, opt_volatility, opt_sharpe = self.portfolio_stats(self.optimal_weights)&#10;            print(f&quot;예상 연간 수익률: {opt_return:.2%}&quot;)&#10;            print(f&quot;예상 연간 변동성: {opt_volatility:.2%}&quot;)&#10;            print(f&quot;샤프 비율: {opt_sharpe:.3f}&quot;)&#10;&#10;            print(f&quot;\n총 투자 금액: {self.investment_amount:,}원&quot;)&#10;            print(&quot;\n=== 투자 배분 ===&quot;)&#10;            for allocation in allocations:&#10;                if allocation['weight'] &gt; 0.001:  # 0.1% 이상만 표시&#10;                    print(f&quot;{allocation['symbol']}: {allocation['amount']:,}원 ({allocation['percentage']:.1f}%)&quot;)&#10;&#10;            # GUI에서 기대하는 형식으로 결과 반환&#10;            result = {&#10;                'method': '클래식 최적화 (Mean-Variance)',&#10;                'allocations': allocations,&#10;                'performance': {&#10;                    'expected_return': opt_return,&#10;                    'volatility': opt_volatility,&#10;                    'sharpe_ratio': opt_sharpe&#10;                },&#10;                'chart_file': chart_file&#10;            }&#10;&#10;            print(&quot;최적화 완료 - ��과 반환&quot;)&#10;            return result&#10;&#10;        except Exception as e:&#10;            print(f&quot;최적화 중 오류 발생: {e}&quot;)&#10;            import traceback&#10;            print(f&quot;상세 오류:\n{traceback.format_exc()}&quot;)&#10;            return None&#10;&#10;&#10;def optimize_portfolio_from_json(json_file_path, investment_amount):&#10;    &quot;&quot;&quot;JSON 파일에서 기업 리스트를 읽어 포트폴리오 최적화 실행&quot;&quot;&quot;&#10;    try:&#10;        with open(json_file_path, 'r', encoding='utf-8') as f:&#10;            stock_data = json.load(f)&#10;&#10;        optimizer = PortfolioOptimizer(stock_data, investment_amount)&#10;        return optimizer.run_optimization()&#10;&#10;    except Exception as e:&#10;        print(f&quot;에러 발생: {e}&quot;)&#10;        return None&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    # 테스트용 예제&#10;    test_stocks = [&quot;005930&quot;, &quot;000660&quot;, &quot;035420&quot;, &quot;051910&quot;, &quot;068270&quot;]  # 삼성전자, SK하��닉스, 네��버, LG화학, 셀트리온&#10;    investment_amount = 10000000  # 1천만원&#10;&#10;    optimizer = PortfolioOptimizer(test_stocks, investment_amount)&#10;    result = optimizer.run_optimization()&#10;&#10;    if result:&#10;        print(&quot;\n포트폴리오 최적화 완료!&quot;)&#10;        print(f&quot;차트 파일: {result['chart_file']}&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>